{"/home/travis/build/npmtest/node-npmtest-snyk/test.js":"/* istanbul instrument in package npmtest_snyk */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-snyk/lib.npmtest_snyk.js":"/* istanbul instrument in package npmtest_snyk */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_snyk = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_snyk = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-snyk/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-snyk && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_snyk */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_snyk\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_snyk.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_snyk.rollup.js'] =\n            local.assetsDict['/assets.npmtest_snyk.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_snyk.__dirname + '/lib.npmtest_snyk.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/index.js":"module.exports = snyk;\n\nvar cluster = require('cluster');\nvar snykConfig = require('./config');\n\nfunction snyk(options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (options.api) {\n    snykConfig.api = options.api;\n  }\n\n  if (options.id) {\n    snyk.id = options.id;\n  }\n\n  // FIXME add in pid + whether master + hostname + all these fields\n\n  snyk.config.isMaster = cluster.isMaster;\n\n  if (options.monitor && snyk.config.isMaster) {\n    if (!snyk.api) {\n      throw new Error('Snyk monitors require an authenticated account ' +\n        'and API token');\n    }\n    // hook();\n    require('./capture')();\n  }\n\n  return snyk;\n}\n\nsnyk.id = snykConfig.id;\n\nvar apiToken = require('./api-token');\n\n// make snyk.api *always* get the latest api token from the config store\nObject.defineProperty(snyk, 'api', {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return apiToken();\n  },\n  set: function (value) {\n    snykConfig.api = value;\n  },\n});\n\nsnyk.modules = require('./modules');\nsnyk.test = require('./snyk-test');\nsnyk.monitor = require('./monitor');\nsnyk.bus = require('./bus');\nsnyk.policy = require('snyk-policy');\nsnyk.isRequired = true; // changed to false when loaded via cli\nsnyk.isolate = {\n  okay: function () {\n    return true;\n  },\n};\n\n// this is the user config, and not the internal config\nsnyk.config = require('./user-config');\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/config.js":"var config = require('snyk-config')(__dirname + '/..');\n\nvar DEFAULT_TIMEOUT = 5 * 60; // in seconds\n\n// allow user config override of the api end point\nvar endpoint = require('./user-config').get('endpoint');\nif (endpoint) {\n  config.API = endpoint;\n}\n\nvar org = require('./user-config').get('org');\nif (!config.org && org) {\n  config.org = org;\n}\n\n// client request timeout\n// to change, set this config key to the desired value in seconds\n// invalid (non-numeric) value will fallback to the default\nvar timeout = require('./user-config').get('timeout');\nif (!config.timeout) {\n  config.timeout = +timeout ? +timeout : DEFAULT_TIMEOUT;\n}\n\n// this is a bit of an assumption that our web site origin is the same\n// as our API origin, but for now it's okay - RS 2015-10-16\nif (!config.ROOT) {\n  var url = require('url');\n  var apiUrl = url.parse(config.API);\n  config.ROOT = apiUrl.protocol + '//' + apiUrl.host;\n}\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-config/lib/index.js":"var debug = require('debug')('snyk:config');\nvar nconf = require('nconf');\nrequire('./nconf-truth');\nvar path = require('path');\nvar pathIsAbsolute = require('path-is-absolute'); // comes with 0.12.x\n\nmodule.exports = function (dir) {\n  if (!dir) {\n    dir = '';\n  }\n\n  if (!pathIsAbsolute(dir)) {\n    throw new Error('config requires absolute path to read from');\n  }\n\n\n  var snykMatch = /^SNYK_.*$/;\n\n  nconf.env({\n    separator: '__',\n    match: snykMatch,\n    whitelist: ['NODE_ENV', 'PORT'],\n  });\n  nconf.argv();\n  nconf.file('local', { file: path.resolve(dir, 'config.local.json') });\n  nconf.file('default', { file: path.resolve(dir, 'config.default.json') });\n\n  var config = nconf.get();\n\n  Object.keys(config).forEach(function (key) {\n    if (key.match(snykMatch)) {\n      config[key.replace(/^SNYK_/, '')] = config[key];\n      delete config[key];\n    }\n  });\n\n  debug('loading from %s', dir, JSON.stringify(config, '', 2));\n\n  return config;\n};","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-config/lib/nconf-truth.js":"/**\n * monkey patch nconf to support TRUE & FALSE on env & arg to port to bool\n */\n\nvar nconf = require('nconf');\nvar common = require('nconf/lib/nconf/common');\n\nnconf.Env.prototype.loadEnv = function () {\n  var self = this;\n\n  this.readOnly = false;\n  Object.keys(process.env).filter(function (key) {\n    if (self.match && self.whitelist.length) {\n      return key.match(self.match) || self.whitelist.indexOf(key) !== -1;\n    } else if (self.match) {\n      return key.match(self.match);\n    } else {\n      return !self.whitelist.length || self.whitelist.indexOf(key) !== -1;\n    }\n  }).forEach(function (key) {\n    var value = process.env[key];\n    if (value === 'TRUE') {\n      value = true;\n    } else if (value === 'FALSE') {\n      value = false;\n    }\n\n    if (self.separator) {\n      self.set(common.key.apply(common, key.split(self.separator)), value);\n    } else {\n      self.set(key, value);\n    }\n  });\n\n  this.readOnly = true;\n  return this.store;\n};","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/user-config.js":"var Configstore = require('configstore');\nvar pkg = require(__dirname + '/../package.json');\nvar config = new Configstore(pkg.name);\n\nmodule.exports = config;","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/api-token.js":"module.exports = api;\nmodule.exports.exists = exists;\n\nvar config = require('./config');\nvar userConfig = require('./user-config');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar error = new Error('NO_API_TOKEN');\nerror.code = 'NO_API_TOKEN';\n\nfunction api() {\n  // note: config.TOKEN will potentially come via the environment\n  return config.api || config.TOKEN || userConfig.get('api');\n}\n\nfunction exists(label) {\n  error.message = label || error.code;\n  return api() ? Promise.resolve() : Promise.reject(error);\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/modules.js":"module.exports = require('snyk-resolve-deps');\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/index.js":"module.exports = function (dir, options) {\n  return physicalTree(dir).then(function (res) {\n    return logicalTree(res, options);\n  });\n};\n\n// expose interal API\nmodule.exports.walk = require('./walk');\nmodule.exports.prune = require('./prune');\nmodule.exports.pluck = require('./pluck');\nmodule.exports.unique = require('./unique');\n\nvar physicalTree = module.exports.physicalTree = require('./deps');\nvar logicalTree = module.exports.logicalTree = require('./logical');\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/walk.js":"module.exports = walk;\n\nfunction walk(deps, filter) {\n  if (!deps) {\n    return [];\n  }\n\n  if (deps.dependencies) {\n    deps = deps.dependencies;\n  }\n\n  Object.keys(deps).forEach(function (name) {\n    var res = filter(deps[name], name, deps);\n    if (!res && deps[name] && deps[name].dep) {\n      walk(deps[name].dependencies, filter);\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/prune.js":"module.exports = prune;\n\nfunction prune(pkg, shouldPrune) {\n  var remove = shouldPrune(pkg);\n  if (!remove) {\n    pkg.dependencies = {};\n  }\n\n  var deps = Object.keys(pkg.dependencies || {});\n\n  if (deps.length) {\n    remove = deps.filter(function (name) {\n      if (prune(pkg.dependencies[name], shouldPrune)) {\n        delete pkg.dependencies[name];\n        return false;\n      }\n      return true;\n    }).length;\n    remove = remove === 0;\n  }\n\n  return remove;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/pluck.js":"module.exports = pluck;\n\nvar semver = require('semver');\nvar moduleToObject = require('snyk-module');\nvar debug = require('debug')('snyk:resolve:pluck');\nvar parseOptions = { loose: true };\n\nfunction pluck(root, path, name, range) {\n  if (range === 'latest') {\n    range = '*';\n  }\n\n  // Cycle through the tree path via the root tree object **ala node require**.\n  // note that we don't need the first item in the path (which is the root\n  // package name).\n  var from = path.slice(0);\n  var rootPath = moduleToObject(from.shift(), parseOptions).name;\n\n  // if the root of the virtual tree doesn't even match our path, bail out\n  if (rootPath !== root.name) {\n    return false;\n  }\n\n  // do a check to see if the last item in the path is actually the package\n  // we're looking for, and if it's not, push it on\n  if (from.length !== 0 &&\n      moduleToObject(from.slice(-1).pop(), parseOptions).name === name) {\n    from.pop();\n  }\n\n  // then we always put the target package on the end of the chain\n  // to ensure it's in exactly the right format to be used in `getMatch`\n  from.push(name + '@' + range);\n\n  debug('using forward search %s@%s in %s', from.join(' > '));\n\n  var match = false;\n  var leaf = root;\n  var realPath = [];\n\n  while (from.length) {\n    var pkg = moduleToObject(from[0], parseOptions);\n    var test = getMatch(leaf, pkg.name, pkg.version);\n\n    if (test) {\n      from.shift();\n      realPath.push(leaf);\n      leaf = test;\n    } else {\n      leaf = realPath.pop();\n      if (!leaf) {\n        return false;\n      }\n    }\n  }\n\n  return leaf.name === name ? leaf : false;\n}\n\nfunction getMatch(root, name, range) {\n  var dep = root.dependencies && root.dependencies[name];\n  if (!dep) {\n    return false;\n  }\n\n  var version = dep.version;\n  debug('pluck match on name...checking version: %s ~= %s', version, range);\n  // make sure it matches our range\n  var semverMatch = semver.validRange(range) &&\n    semver.valid(version) &&\n    semver.satisfies(version, range);\n\n  var externalPackage = !semver.validRange(range) &&\n    range.indexOf(':/') !== -1;\n\n  if (semverMatch || externalPackage) {\n    debug('pluck match');\n    if (!dep.dep) {\n      dep.dep = range;\n    }\n    return dep;\n  }\n\n  return false;\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-module/lib/index.js":"module.exports = moduleToObject;\nmodule.exports.encode = encode;\n\nvar debug = require('debug')('snyk:module');\nvar gitHost = require('hosted-git-info');\n\n/**\n * Converts a string module name to an object\n * @param  {String} str     Required module name (can also include @version)\n * @param  {String} version Optional version\n * @param  {Object} options { loose: Boolean }\n * @return {Object}         Containing .name & .version properties\n */\nfunction moduleToObject(str, version, options) {\n  if (!str) {\n    throw new Error('requires string to parse into module');\n  }\n\n  if (version && !options && typeof version === 'object') {\n    options = version;\n    version = null;\n  }\n\n  if (version && str.lastIndexOf('@') < 1) {\n    debug('appending version onto string');\n    str += '@' + version;\n  }\n\n  // first try with regular git urls\n  var gitObject = looksLikeUrl(str);\n  if (gitObject) {\n    // then the string looks like a url, let's try to parse it\n    return supported(str, fromGitObject(gitObject), options);\n  }\n\n  var parts = str.split('@');\n\n  if (str.indexOf('@') === 0) {\n    // put the scoped package name back together\n    parts = parts.slice(1);\n    parts[0] = '@' + parts[0];\n  }\n\n  // then as a backup, try pkg@giturl\n  gitObject = parts[1] && looksLikeUrl(parts[1]);\n\n  if (gitObject) {\n    // then the string looks like a url, let's try to parse it\n    return supported(str, fromGitObject(gitObject, parts[0]), options);\n  }\n\n  if (parts.length === 1) { // no version\n    parts.push('*');\n  }\n\n  var module = {\n    name: parts[0],\n    version: parts[1],\n  };\n\n  return supported(str, module, options);\n}\n\nfunction looksLikeUrl(str) {\n  if (str.slice(-1) === '/') {\n    // strip the trailing slash since we can't parse it properly anyway\n    str = str.slice(0, -1);\n  }\n\n  if (str.toLowerCase().indexOf('://github.com/') !== -1 &&\n      str.indexOf('http') === 0) {\n    // attempt to get better compat with our parser by stripping the github\n    // and url parts\n    // examples:\n    // - https://github.com/Snyk/snyk/releases/tag/v1.14.2\n    // - https://github.com/Snyk/vulndb/tree/snapshots\n    // - https://github.com/Snyk/snyk/commit/75477b18\n    var parts = str.replace(/https?:\\/\\/github.com\\//, '').split('/');\n    str = parts.shift() + '/' + parts.shift();\n\n    if (parts.length) {\n      str += '#' + parts.pop();\n    }\n  }\n\n  var obj = gitHost.fromUrl(str);\n\n  return obj;\n}\n\nfunction fromGitObject(obj) {\n  var error = false;\n\n  // debug('parsed from hosted-git-info');\n\n  /* istanbul ignore if */\n  if (!obj.project || !obj.user) {\n    // this should never actually occur\n    error = new Error('not supported: failed to fully parse');\n    error.code = 501;\n    throw error;\n  }\n\n  var module = {\n    name: obj.project,\n    version: obj.user + '/' + obj.project,\n  };\n\n  if (obj.committish) {\n    module.version += '#' + obj.committish;\n  }\n\n  return module;\n}\n\nfunction encode(name) {\n  return name[0] + encodeURIComponent(name.slice(1));\n}\n\nfunction supported(str, module, options) {\n  if (!options) {\n    options = {};\n  }\n\n  var error;\n\n  if (options.packageManager === 'maven') {\n    if (str.indexOf(':') === -1) {\n      throw new Error('invalid Maven package name: ' + str);\n    }\n    return module;\n  }\n\n  var protocolMatch = module.version.match(/^(https?:)|(git[:+])/i);\n  if (protocolMatch ||\n      module.name.indexOf('://') !== -1) {\n    // we don't support non-npm modules atm\n    debug('not supported %s@%s (ext)', module.name, module.version);\n    if (options.loose) {\n      delete module.version;\n    } else {\n      error = new Error('not supported: external module: ' + toString(module));\n    }\n  }\n\n  if (error) {\n    error.code = 501; // not implemented\n    throw error;\n  }\n\n  if (module.version === 'latest' || !module.version) {\n    module.version = '*';\n  }\n\n  debug('%s => { name: \"%s\", version: \"%s\" }',\n    str, module.name, module.version);\n\n  return module;\n}\n\nfunction toString(module) {\n  return module.name + '@' + module.version;\n}\n\n/* istanbul ignore if */\nif (!module.parent) {\n  // support simple cli testing\n  console.log(moduleToObject(process.argv[2], { loose: false }));\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/unique.js":"module.exports = unique;\n\nvar walk = require('./walk');\n\nfunction unique(deps) {\n  var res = copy(deps);\n  res.dependencies = {};\n\n  walk(deps, function (dep) {\n    var shallowCopy = copy(dep);\n    res.dependencies[dep.name + '@' + dep.version] = shallowCopy;\n  });\n\n  return res;\n}\n\nfunction copy(dep) {\n  return Object.keys(dep).filter(function (key) {\n    return key.toLowerCase().indexOf('dependencies') === -1;\n  }).reduce(function (acc, curr) {\n    acc[curr] = dep[curr];\n    return acc;\n  }, {});\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/deps.js":"module.exports = loadModules;\n\nvar depTypes = require('./dep-types');\nvar fs = require('then-fs');\nvar _ = require('lodash');\nvar debug = require('debug')('snyk:resolve:deps');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar path = require('path');\nvar semver = require('semver');\nvar resolve = require('snyk-resolve');\nvar tryRequire = require('snyk-try-require');\n\n// FIXME only supports dependancies & dev deps not opt-deps\nfunction loadModules(root, depType) {\n  tryRequire.cache.reset(); // reset the package cache on re-run\n  return loadModulesInternal(root, depType || null).then(function (tree) {\n    // ensure there's no missing packages our known root deps\n    var missing = [];\n    if (tree.__dependencies) {\n      Object.keys(tree.__dependencies).forEach(function (name) {\n        if (!tree.dependencies[name]) {\n          missing.push(resolve(name, root).then(function (dir) {\n            return loadModulesInternal(dir, depTypes.PROD, {\n              __from: [tree.name + '@' + tree.version, name],\n            });\n          }).catch(function (e) {\n            if (e.code === 'NO_PACKAGE_FOUND') {\n              return false;\n            }\n          }));\n        }\n      });\n    }\n\n    if (missing.length) {\n      return Promise.all(missing).then(function (packages) {\n        packages.filter(Boolean).forEach(function (pkg) {\n          pkg.dep = tree.__dependencies[pkg.name];\n          tree.dependencies[pkg.name] = pkg;\n        });\n        return tree;\n      });\n    }\n\n    return tree;\n  });\n\n}\n\nfunction loadModulesInternal(root, rootDepType, parent) {\n  if (!rootDepType) {\n    rootDepType = depTypes.EXTRANEOUS;\n  }\n\n  if (typeof root !== 'string') {\n    return Promise.reject(new Error('module path must be a string'));\n  }\n\n  var modules = {};\n  var dir = path.resolve(root, 'package.json');\n  // 1. read package.json for written deps\n  var promise = tryRequire(dir).then(function (pkg) {\n    // if there's a package found, collect this information too\n    if (pkg) {\n      var full = pkg.name + '@' + (pkg.version || '0.0.0');\n      modules = {\n        name: pkg.name,\n        version: pkg.version || null,\n        license: pkg.license || 'none',\n        depType: rootDepType,\n        hasDevDependencies: !!pkg.devDependencies,\n        full: full,\n        __from: (parent || { __from: [] }).__from,\n        __devDependencies: pkg.devDependencies,\n        __dependencies: pkg.dependencies,\n        __optionalDependencies: pkg.optionalDependencies,\n        __bundleDependencies: pkg.bundleDependencies,\n        __filename: pkg.__filename,\n      };\n\n      // allows us to add to work out the full path that the package was\n      // introduced via\n      pkg.__from = modules.__from.concat(full);\n      pkg.full = modules.full;\n\n      // flag and track where a shrinkwrapped package comes from\n      if (!pkg.shrinkwrap && parent && parent.shrinkwrap) {\n        pkg.shrinkwrap = parent.shrinkwrap;\n      } else if (pkg.shrinkwrap) {\n        pkg.shrinkwrap = pkg.full;\n      }\n\n      // this is a special case for the root package to get a consistent\n      // __from path, so that the complete path (including it's own pkg name)\n      if (modules.__from.length === 0) {\n        modules.__from.push(full);\n      }\n    } else {\n      throw new Error(dir + ' is not a node project');\n    }\n    modules.dependencies = {};\n\n    // 2. check actual installed deps\n    return fs.readdir(path.resolve(root, 'node_modules')).then(function (dirs) {\n      var res = dirs.map(function (dir) {\n        // completely ignore `.bin` npm helper dir\n        if (dir === '.bin' || dir === '.DS_Store') {\n          return null;\n        }\n\n        // this is a scoped namespace, and we'd expect to find directories\n        // inside *this* `dir`, so treat differently\n        if (dir.indexOf('@') === 0) {\n          debug('scoped reset on %s', dir);\n          dir = path.resolve(root, 'node_modules', dir);\n          return fs.readdir(dir).then(function (dirs) {\n            return Promise.all(dirs.map(function (scopedDir) {\n              return tryRequire(path.resolve(dir, scopedDir, 'package.json'));\n            }));\n          });\n        }\n\n        // otherwise try to load a package.json from this node_module dir\n        dir = path.resolve(root, 'node_modules', dir, 'package.json');\n        return tryRequire(dir);\n      });\n\n      return Promise.all(res).then(function (res) {\n        res = _.flatten(res).filter(Boolean);\n\n        // if res.length === 0 we used to throw MISSING_NODE_MODULES but we're\n        // not doing that now, and I think it's okay.\n\n        res.reduce(function (acc, curr) {\n          var license;\n          var licenses = curr.license || curr.licenses;\n\n          if (Array.isArray(licenses)) {\n            license = licenses.reduce(function (acc, curr) {\n              acc.push((curr || {}).type || curr);\n              return acc;\n            }, []).join('/');\n          } else {\n            license = (licenses || {}).type || licenses;\n          }\n\n          var depInfo = depTypes(curr.name, pkg);\n          var depType = depInfo.type || rootDepType;\n          var depFrom = depInfo.from;\n\n          var valid = false;\n          if (depFrom) {\n            valid = semver.satisfies(curr.version, depFrom);\n          }\n\n          var full = curr.name + '@' + (curr.version || '0.0.0');\n\n          acc[curr.name] = {\n            name: curr.name,\n            version: curr.version || null,\n            full: full,\n            valid: valid,\n            depType: depType,\n            snyk: curr.snyk,\n            license: license || 'none',\n            dep: depFrom || null,\n            __from: pkg.__from.concat(full),\n            __devDependencies: curr.devDependencies,\n            __dependencies: curr.dependencies,\n            __optionalDependencies: curr.optionalDependencies,\n            __bundleDependencies: curr.bundleDependencies,\n            __filename: curr.__filename,\n          };\n\n          if (depInfo.bundled) {\n            acc[curr.name].bundled = acc[curr.name].__from.slice(0);\n          }\n\n          if (pkg.shrinkwrap) {\n            acc[curr.name].shrinkwrap = pkg.shrinkwrap;\n          }\n\n          return acc;\n        }, modules.dependencies);\n\n        return modules;\n      });\n    }).then(function (modules) {\n      var deps = Object.keys(modules.dependencies);\n\n      var promises = deps.map(function (dep) {\n        var depType = modules.dependencies[dep].depType;\n        var dir = path.resolve(root, 'node_modules', dep);\n        return loadModulesInternal(dir, depType, pkg);\n      });\n\n      return Promise.all(promises).then(function (res) {\n        res.forEach(function (mod) {\n          modules.dependencies[mod.name].dependencies = mod.dependencies;\n        });\n\n        return modules;\n      });\n    }).catch(function (error) {\n      // TODO decide whether it's okay that we keep throwing errors\n      // will this process get faster without it? (possibly...)\n      /* istanbul ignore else  */\n      if (error.code === 'ENOENT') {\n        // there's no node_modules directory, that's fine, there's no deps\n        modules.dependencies = {};\n        return modules;\n      }\n\n      /* istanbul ignore next */\n      throw error;\n    });\n  });\n\n  return promise;\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/dep-types.js":"// Dependency types.\n// We don't call out all of them, only the ones relevant to our behavior.\n// extraneous means not found in package.json files, prod means not dev ATM\nvar depTypes = module.exports = function (depName, pkg) {\n  var type = null;\n  var from = 'unknown';\n\n  if (pkg.devDependencies && pkg.devDependencies[depName]) {\n    type = depTypes.DEV;\n    from = pkg.devDependencies[depName];\n  }\n\n  if (pkg.optionalDependencies && pkg.optionalDependencies[depName]) {\n    type = depTypes.OPTIONAL;\n    from = pkg.optionalDependencies[depName];\n  }\n\n  // production deps trump all\n  if (pkg.dependencies && pkg.dependencies[depName]) {\n    type = depTypes.PROD;\n    from = pkg.dependencies[depName];\n  }\n\n  var bundled = !!(pkg.bundleDependencies &&\n    pkg.bundleDependencies.indexOf(depName) !== -1);\n\n  return {\n    type: type,\n    from: from,\n    bundled: bundled,\n  };\n};\n\nmodule.exports.EXTRANEOUS = 'extraneous';\nmodule.exports.OPTIONAL = 'optional';\nmodule.exports.PROD = 'prod';\nmodule.exports.DEV = 'dev';\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve/lib/index.js":"module.exports = resolvePkg;\nmodule.exports.sync = sync;\n\nvar fs = require('then-fs');\nvar path = require('path');\nvar debug = require('debug')('snyk:resolve');\n\nfunction resolvePkg(name, basedir) {\n  if (!basedir) {\n    basedir = process.cwd();\n  }\n\n  var filename = path.resolve(basedir, 'node_modules', name, 'package.json');\n  debug('%s: %s', name, filename);\n  return fs.stat(filename).then(function (stat) {\n    if (stat.isFile()) {\n      return path.dirname(filename);\n    }\n  }).catch(function (error) {\n    debug('%s: not found on %s (root? %s)', name, basedir, isRoot(basedir));\n    if (isRoot(basedir)) {\n      debug('at root');\n      error = new Error('package not found ' + name);\n      error.code = 'NO_PACKAGE_FOUND';\n      throw error;\n    }\n  }).then(function (dir) {\n    if (dir) {\n      debug('%s: FOUND AT %s', name, dir);\n      return dir;\n    }\n\n    debug('%s: cycling down', name);\n    return resolvePkg(name, path.resolve(basedir, '..'));\n  });\n}\n\nfunction sync(name, basedir) {\n  if (!basedir) {\n    basedir = process.cwd();\n  }\n\n  var filename = path.resolve(basedir, 'node_modules', name, 'package.json');\n  debug('%s: %s', name, filename);\n\n  var isFile = function (file) {\n    var stat;\n    try {\n      stat = fs.statSync(file);\n    } catch (error) {\n      if (error && error.code === 'ENOENT') {\n        return false;\n      }\n    }\n    return stat.isFile() || stat.isFIFO();\n  };\n\n  if (isFile(filename)) {\n    debug('%s: FOUND AT %s', name, filename);\n    return path.dirname(filename);\n  }\n\n  if (isRoot(basedir)) {\n    debug('%s: not found on %s (now at root)', name, filename);\n    var error = new Error('package not found ' + name);\n    error.code = 'NO_PACKAGE_FOUND';\n    throw error;\n  }\n\n  debug('%s: cycling down', name);\n  return sync(name, path.resolve(basedir, '..'));\n}\n\nfunction isRoot(dir) {\n  var parsed = parse(dir);\n  return parsed.root === parsed.dir && !parsed.base;\n}\n\n// FIXME determine whether this would work properly on windows in 0.10\nfunction parse(dir) {\n  /* istanbul ignore else  */\n  // jscs:disable requireEarlyReturn\n  if (path.parse) {\n    return path.parse(dir);\n  } else {\n    var split = dir.split(path.sep);\n    var root = split[0] + path.sep;\n    return {\n      base: split[1],\n      root: root,\n      dir: dir,\n    };\n  }\n  // jscs:enable requireEarlyReturn\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-try-require/lib/try-require.js":"module.exports = tryRequire;\n\nvar fs = require('then-fs');\nvar path = require('path');\nvar debug = require('debug')('snyk:resolve:try-require');\nvar cloneDeep = require('lodash.clonedeep');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar lru = require('lru-cache');\nvar options = { max: 100, maxAge: 1000 * 60 * 60 };\nvar cache = lru(options);\n\nmodule.exports.cache = cache; // allows for a reset\n\nfunction tryRequire(filename) {\n  var cached = cache.get(filename);\n  if (cached) {\n    var res = cloneDeep(cached);\n    /* istanbul ignore else */\n    if (process.env.TAP) {\n      res.__cached = true;\n    }\n    return Promise.resolve(res);\n  }\n  return fs.readFile(filename, 'utf8')\n    .then(function (pkgStr) {\n      var pkg = JSON.parse(pkgStr);\n      pkg.leading = pkgStr.match(/^(\\s*){/)[1];\n      pkg.trailing = pkgStr.match(/}(\\s*)$/)[1];\n      return pkg;\n    })\n    .catch(function (e) {\n      debug('tryRequire silently failing on %s', e.message);\n      return null;\n    })\n    .then(function (pkg) {\n      if (!pkg) {\n        return pkg;\n      }\n\n      // fixes potential issues later on\n      if (!pkg.devDependencies) {\n        pkg.devDependencies = {};\n      }\n\n      if (!pkg.dependencies) {\n        pkg.dependencies = {};\n      }\n\n      if (!pkg.name) {\n        pkg.name = path.basename(path.dirname(filename));\n      }\n\n      pkg.__filename = filename;\n\n      // test for npm-shrinkwrap and find a .snyk policy file whilst we're at it\n      var dir = path.dirname(filename);\n      var promises = [\n        fs.stat(path.resolve(dir, '.snyk')).catch(pass),\n        fs.stat(path.resolve(dir, 'npm-shrinkwrap.json')).catch(pass),\n      ];\n\n      return Promise.all(promises).then(function (res) {\n        if (!pkg.snyk) {\n          pkg.snyk = res[0].isFile();\n        }\n        if (pkg.snyk) {\n          pkg.snyk = dir;\n        }\n\n        if (res[1].isFile()) {\n          pkg.shrinkwrap = true;\n        }\n\n        return pkg;\n      });\n    })\n    .then(function (pkg) {\n      cache.set(filename, pkg);\n      return cloneDeep(pkg);\n    });\n}\n\nvar pass = function () {\n  return {\n    isFile: function () { return false; },\n  };\n};\n\n/* istanbul ignore if */\nif (!module.parent) {\n  tryRequire(process.argv[2])\n    .then(JSON.stringify)\n    .then(console.log)\n    .catch(console.log);\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-resolve-deps/lib/logical.js":"module.exports = logicalTree;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar pluck = require('./pluck');\nvar walk = require('./walk');\nvar unique = require('./unique');\nvar path = require('path');\nvar depTypes = require('./dep-types');\nvar colour = require('ansicolors');\nvar moduleToObject = require('snyk-module');\nvar _ = require('lodash');\nvar format = require('util').format;\nvar ext = colour.bgBlack(colour.green('extraneous'));\nvar problems = [];\n\n/**\n * This code will build up the logical tree representation of a node package\n * and it's dependencies. This is based initially on reading the directory\n * structure and the package.json files found in each directory.\n *\n * After which, we parse the tree and read the `__dependencies` looking for\n * their actual location on disk (or if it's missing, etc) - marking as we\n * go along that the leaf has been used.\n *\n * After that, we need to search for the original tree for unused leafs, and\n * these will be marked as extraneous and carried through to the logical\n * tree at the same depth.\n *\n * Important: some extraneous modules will actually be from devDependencies\n * from the root level, so we need to handle these carefully.\n */\n\n\nfunction logicalTree(fileTree, options) {\n  if (!options) {\n    options = {};\n  }\n\n  problems = [];\n  var logicalRoot = copy(fileTree, fileTree.__from, true);\n  logicalRoot.dependencies = walkDeps(fileTree, fileTree);\n\n  var removedPaths = [];\n\n  if (!options.dev) {\n    // do a shallow pass on the deps and strip out dev deps\n    Object.keys(fileTree.dependencies).forEach(function (name) {\n      var dep = fileTree.dependencies[name];\n      // if we're not interested in devDeps, then strip them out\n      if (dep.depType === depTypes.DEV) {\n        // since dev deps are only ever on the root, we know we can remove it\n        // directly from the logicalRoot.dependencies\n        removedPaths.push(dep.__from);\n        delete logicalRoot.dependencies[dep.name];\n        return;\n      }\n    });\n  }\n\n  logicalRoot.numFileDependencies = 0;\n\n  walk(fileTree.dependencies, function (dep) {\n    logicalRoot.numFileDependencies++;\n    if (!dep.__used) {\n      var deppath = dep.__from.slice(0, -1).toString();\n      var removed = removedPaths.filter(function (path) {\n        return deppath.indexOf(path) === 0;\n      }).length;\n\n      if (removed) {\n        return false; // this was from a dev dep, so let's lose it\n      }\n\n      var leaf = copy(dep);\n\n      var issue = format('%s: %s@%s (from %s) > %s', ext, leaf.name,\n        leaf.version, leaf.dep, path.relative('.', leaf.__filename));\n      leaf.problems = [issue];\n      problems.push(issue);\n      leaf.extraneous = true;\n      leaf.depType = depTypes.EXTRANEOUS;\n      leaf.dependencies = walkDeps(fileTree, dep);\n      walk(leaf.dependencies, function (dep) {\n        dep.extraneous = true;\n        dep.depType = depTypes.EXTRANEOUS;\n      });\n      insertLeaf(logicalRoot, leaf, dep.__from);\n    }\n  });\n\n  logicalRoot.numDependencies = Object.keys(\n    unique(logicalRoot).dependencies\n  ).length;\n\n  logicalRoot.pluck = pluck.bind(null, fileTree);\n  logicalRoot.unique = unique.bind(null, logicalRoot);\n  logicalRoot.problems = problems.slice(0);\n\n  return logicalRoot;\n}\n\nfunction insertLeaf(tree, leaf, from) {\n  // remove the root of the path and covert to names only\n  var path = (from || []).slice(1, -1).map(function (pkg) {\n    return moduleToObject(pkg).name;\n  });\n  var entry = tree.dependencies;\n  for (var i = 0; i < path.length; i++) {\n    if (entry[path[i]]) {\n      entry = entry[path[i]].dependencies;\n    }\n  }\n  entry[leaf.name] = leaf;\n}\n\nfunction walkDeps(root, tree, from) {\n  if (!from) {\n    from = tree.__from;\n  }\n\n  // only include the devDeps on the root level package\n  var deps = _.extend({}, tree.__dependencies,\n    tree.__from && from.length === 1 ? tree.__devDependencies : {});\n\n  deps = _.extend(deps, tree.__optionalDependencies);\n\n  return Object.keys(deps).reduce(function walkDepsPicker(acc, curr) {\n    // only attempt to walk this dep if it's not in our path already\n    if (tree.__from.indexOf(curr) === -1) {\n      var version = deps[curr];\n      var dep = pluck(root, tree.__from, curr, version);\n\n      if (!dep) {\n        problems.push(format('missing: %s@%s, required by %s', curr, version,\n          from.join(' > ')));\n        return acc;\n      }\n\n      if (from.indexOf(dep.full) === -1) {\n        var pkg = acc[dep.name] = copy(dep, from.concat(dep.full));\n        dep.__used = true;\n        var info = depTypes(dep.name, {\n          dependencies: tree.__dependencies,\n          devDependencies: tree.__devDependencies,\n          optionalDependencies: tree.__optionalDependencies,\n          bundleDependencies: tree.__bundleDependencies,\n        });\n\n        pkg.depType = info.type;\n        pkg.dep = info.from;\n        if (tree.bundled) { // carry the bundled flag down from the parent\n          dep.bundled = pkg.bundled = tree.bundled;\n        }\n\n        pkg.dependencies = walkDeps(root, dep, pkg.from);\n      }\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction copy(leaf, from) {\n  if (!from) {\n    from = leaf.__from;\n  }\n\n  var res = Object.keys(leaf).reduce(function copyIterator(acc, curr) {\n    if (leaf[curr] !== undefined && curr.indexOf('__') !== 0) {\n      if (curr !== 'dependencies') {\n        acc[curr] = leaf[curr];\n      }\n    }\n    return acc;\n  }, {});\n\n  res.from = from.slice(0);\n  res.__filename = leaf.__filename;\n\n  return res;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/snyk-test/index.js":"module.exports = test;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar detect = require('../detect');\nvar runTest = require('./run-test');\n\nfunction test(root, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (!options) {\n    options = {};\n  }\n\n  var promise = executeTest(root, options);\n  if (callback) {\n    promise.then(function (res) {\n      callback(null, res);\n    }).catch(callback);\n  }\n  return promise;\n}\n\nfunction executeTest(root, options) {\n  try {\n    var packageManager = options.packageManager ||\n      detect.detectPackageManager(root, options);\n    options.packageManager = packageManager;\n    return run(root, options)\n    .then(function (res) {\n      res.packageManager = packageManager;\n      return res;\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nfunction run(root, options) {\n  var packageManager = options.packageManager;\n  if (new Set(['npm', 'yarn']).has(packageManager)) {\n    return require('./npm')(root, options);\n  }\n  if (!new Set(['rubygems', 'maven']).has(packageManager)) {\n    throw new Error('Unsupported package manager: ' + packageManager);\n  }\n  return runTest(packageManager, root, options);\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/detect.js":"module.exports = {\n  detectPackageManager: detectPackageManager,\n  detectPackageFile: detectPackageFile,\n};\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar fs = require('then-fs');\nvar path = require('path');\n\nvar DETECTABLE_FILES = [\n  'yarn.lock',\n  'package.json',\n  'Gemfile',\n  'Gemfile.lock',\n  'pom.xml',\n];\n\nvar DETECTABLE_PACKAGE_MANAGERS = {\n  Gemfile: 'rubygems',\n  'Gemfile.lock': 'rubygems',\n  '.gemspec': 'rubygems',\n  'package.json': 'npm',\n  'pom.xml': 'maven',\n  'yarn.lock': 'yarn',\n};\n\nfunction detectPackageManager(root, options) {\n  var packageManager;\n  if (isCodeTest(root)) {\n    if (localFileSuppliedButNotFound(root, options.file)) {\n      throw new Error('File not found: ' + options.file);\n    }\n    var file = options.file || detectPackageFile(root) || 'package.json';\n    packageManager = detectPackageManagerFromFile(file);\n  } else {\n    var registry = options.registry || 'npm';\n    packageManager = detectPackageManagerFromRegistry(registry);\n  }\n  return packageManager;\n}\n\n// User supplied a \"local\" file, but that file doesn't exist\nfunction localFileSuppliedButNotFound(root, file) {\n  return file && fs.existsSync(root) &&\n    !fs.existsSync(path.resolve(root, file));\n}\n\nfunction isCodeTest(root) {\n  return isRepo(root) || fs.existsSync(root);\n}\n\nfunction isRepo(root) {\n  return root.indexOf('github.com') !== -1;\n}\n\nfunction detectPackageFile(root) {\n  for (var i = 0; i < DETECTABLE_FILES.length; i++) {\n    var file = DETECTABLE_FILES[i];\n    if (fs.existsSync(path.resolve(root, file))) {\n      return file;\n    }\n  }\n  return null;\n}\n\nfunction detectPackageManagerFromFile(file) {\n  var key = path.basename(file);\n  if (/\\.gemspec$/.test(key)) {\n    key = '.gemspec';\n  }\n  if (!(key in DETECTABLE_PACKAGE_MANAGERS)) {\n    throw new Error('Could not detect package manager for file: ' + file);\n  }\n  return DETECTABLE_PACKAGE_MANAGERS[key];\n}\n\nfunction detectPackageManagerFromRegistry(registry) {\n  return registry;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/snyk-test/run-test.js":"module.exports = runTest;\n\nvar debug = require('debug')('snyk');\nvar fs = require('then-fs');\nvar moduleToOjbect = require('snyk-module');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\n\nvar analytics = require('../analytics');\nvar config = require('../config');\nvar getModuleInfo = require('../module-info');\nvar isCI = require('../is-ci');\nvar request = require('../request');\nvar snyk = require('../');\nvar spinner = require('../spinner');\n\n\nfunction runTest(packageManager, root, options) {\n  return Promise.resolve().then(function () {\n    var policyLocations = [root];\n    var hasDevDependencies = false;\n    var lbl = 'Querying vulnerabilities database...';\n    return assemblePayload(root, options, policyLocations)\n    .then(spinner(lbl))\n    .then(function (payload) {\n      return new Promise(function (resolve, reject) {\n        request(payload, function (error, res, body) {\n          if (error) {\n            return reject(error);\n          }\n\n          if (res.statusCode !== 200) {\n            var err = new Error(body && body.error ?\n              body.error :\n              res.statusCode);\n\n            // this is the case where a local module has been tested, but\n            // doesn't have any production deps, but we've noted that they\n            // have dep deps, so we'll error with a more useful message\n            if (res.statusCode === 404 && hasDevDependencies) {\n              err.code = 'NOT_FOUND_HAS_DEV_DEPS';\n            } else {\n              err.code = res.statusCode;\n            }\n\n            if (res.statusCode === 500) {\n              debug('Server error', body.stack);\n            }\n\n            return reject(err);\n          }\n\n          resolve(body);\n        });\n      });\n    }).then(function (res) {\n      analytics.add('vulns-pre-policy', res.vulnerabilities.length);\n      options.loose = true; // allows merge without root policy\n      return snyk.policy.load(policyLocations, options)\n      .then(function (policy) {\n        return policy.filter(res, root);\n      }, function (error) { // note: inline catch, to handle error from .load\n        // the .snyk file wasn't found, which is fine, so we'll return the vulns\n        if (error.code === 'ENOENT') {\n          return res;\n        }\n        throw error;\n      }).then(function (res) {\n        analytics.add('vulns', res.vulnerabilities.length);\n\n        // add the unique count of vulnerabilities found\n        res.uniqueCount = 0;\n        var seen = {};\n        res.uniqueCount = res.vulnerabilities.reduce(function (acc, curr) {\n          if (!seen[curr.id]) {\n            seen[curr.id] = true;\n            acc++;\n          }\n          return acc;\n        }, 0);\n\n        return res;\n      });\n    }).then(spinner.clear(lbl));\n  });\n}\n\nfunction assemblePayload(root, options, policyLocations) {\n  var local = fs.existsSync(root);\n  analytics.add('local', local);\n  analytics.add('packageManager', options.packageManager);\n  return local ? assembleLocalPayload(root, options, policyLocations)\n    : assembleRemotePayload(root, options);\n}\n\nfunction assembleLocalPayload(root, options, policyLocations) {\n  return getModuleInfo(options.packageManager, root, options)\n  .then(function (module) {\n    analytics.add('policies', policyLocations.length);\n    analytics.add('packageName', module.name);\n    analytics.add('packageVersion', module.version);\n    analytics.add('package', module.name + '@' + module.version);\n    var payload = {\n      method: 'POST',\n      url: vulnUrl(options.packageManager),\n      json: true,\n      headers: {\n        'x-is-ci': isCI,\n        authorization: 'token ' + snyk.api,\n      },\n      body: module,\n    };\n    if (options.org) {\n      payload.qs = {org: options.org};\n    }\n    return payload;\n  });\n}\n\nfunction assembleRemotePayload(root, options) {\n  var module = moduleToOjbect(root);\n  debug('testing remote: %s', module.name + '@' + module.version);\n  var encodedName = encodeURIComponent(module.name + '@' + module.version);\n  analytics.add('packageName', module.name);\n  analytics.add('packageVersion', module.version);\n  analytics.add('package', module.name + '@' + module.version);\n  var payload = {\n    method: 'GET',\n    url: vulnUrl(options.packageManager) + '/' + encodedName,\n    json: true,\n    headers: {\n      'x-is-ci': isCI,\n      authorization: 'token ' + snyk.api,\n    },\n  };\n  if (options.org) {\n    payload.qs = {org: options.org};\n  }\n  return Promise.resolve(payload);\n}\n\nfunction vulnUrl(packageManager) {\n  return config.API + '/vuln/' + packageManager;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/analytics.js":"module.exports = analytics;\nmodule.exports.single = postAnalytics;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar snyk = require('./');\nvar config = require('./config');\nvar version = require('./version');\nvar request = require('./request');\nvar isCI = require('./is-ci');\nvar debug = require('debug')('snyk');\nvar os = require('os');\nvar osName = require('os-name');\nvar interfaces = os.networkInterfaces() || os.getNetworkInterfaces();\nvar crypto = require('crypto');\nvar uuid = require('uuid');\n\nvar metadata = {};\n\nfunction analytics(data) {\n  if (!data) {\n    data = {};\n  }\n\n  // merge any new data with data we picked up along the way\n  if (Array.isArray(data.args)) {\n    // this is an overhang from the cli/args.js and we don't want it\n    delete (data.args.slice(-1).pop() || {})._;\n  }\n\n  if (Object.keys(metadata).length) {\n    data.metadata = metadata;\n  }\n\n  return postAnalytics(data);\n}\n\nfunction postAnalytics(data) {\n  // if the user opt'ed out of analytics, then let's bail out early\n  // ths applies to all sending to protect user's privacy\n  if (snyk.config.get('disable-analytics') || config.DISABLE_ANALYTICS) {\n    debug('analytics disabled');\n    return Promise.resolve();\n  }\n\n  // get fingerprint from mac address\n  // snyk version\n  return version().then(function (version) {\n    data.version = version;\n    data.os = osName(os.platform(), os.release());\n    data.nodeVersion = process.version;\n\n    var mac = getMAC() || uuid.v4();\n    var shasum = crypto.createHash('sha1');\n    data.id = shasum.update(mac).digest('hex');\n\n    var headers = {};\n    if (snyk.api) {\n      headers.authorization = 'token ' + snyk.api;\n    }\n\n    data.ci = isCI;\n\n    debug(data);\n\n    return request({\n      body: {\n        data: data,\n      },\n      url: config.API + '/analytics/cli',\n      json: true,\n      method: 'post',\n      headers: headers,\n    });\n  }).catch(function (error) {\n    debug(error); // this swallows the analytics error\n  });\n}\n\nanalytics.reset = function () {\n  metadata = {};\n};\n\nanalytics.add = function (key, value) {\n  debug('add', key, value);\n  if (metadata[key]) {\n    if (!Array.isArray(metadata[key])) {\n      metadata[key] = [metadata[key]];\n    }\n    metadata[key].push(value);\n  } else {\n    metadata[key] = value;\n  }\n};\n\n// via http://git.io/v0Xze\n// because we can't just pick the first mac address :-\\\nfunction getMAC() {\n  var name;\n  return Object.keys(interfaces).sort().reduce(function (acc, curr) {\n    if (curr.indexOf('en') === 0 && name.indexOf('en') === -1) {\n      name = curr;\n      return interfaces[curr][0].address;\n    }\n\n    if (acc) {\n      return acc;\n    }\n\n    if (curr.indexOf('lo') === -1 && interfaces[curr].length) {\n      name = curr;\n      return interfaces[curr][0].address;\n    }\n  }, '');\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/version.js":"var path = require('path');\nvar command = require('./exec');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar root = path.resolve(__dirname, '..');\n\nmodule.exports = function () {\n  return new Promise(function (resolve) {\n    var filename = path.resolve(root, 'package.json');\n    var version = require(filename).version;\n\n    if (version && version !== '0.0.0') {\n      return resolve(version);\n    }\n\n    // else we're in development, give the commit out\n    // get the last commit and whether the working dir is dirty\n    var promises = [\n      branch(),\n      commit(),\n      dirty(),\n    ];\n\n    resolve(Promise.all(promises).catch(function () {\n      // handle any point where the git based lookup fails\n      return ['unknown', '', '0'];\n    }).then(function (res) {\n      var branch = res[0];\n      var commit = res[1];\n      var dirtyCount = parseInt(res[2], 10);\n      var curr = branch + ': ' + commit;\n      if (dirtyCount !== 0) {\n        curr += ' (' + dirtyCount + ' dirty files)';\n      }\n\n      return curr;\n    }));\n  });\n};\n\nfunction commit() {\n  return command('git rev-parse HEAD', root);\n}\n\nfunction branch() {\n  return command('git rev-parse --abbrev-ref HEAD', root);\n}\n\nfunction dirty() {\n  return command('expr $(git status --porcelain 2>/dev/null| ' +\n      'egrep \"^(M| M)\" | wc -l)', root);\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/exec.js":"var exec = require('child_process').exec;\n\nmodule.exports = command;\n\nfunction command(cmd, root) {\n  return new Promise(function (resolve, reject) {\n    exec(cmd, { cwd: root }, function (err, stdout, stderr) {\n      var error = stderr.trim();\n      if (error) {\n        return reject(new Error(error + ' / ' + cmd));\n      }\n      resolve(stdout.split('\\n').join(''));\n    });\n  });\n}\n\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/request.js":"module.exports = makeRequest;\n\nvar debug = require('debug')('snyk:req');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar request = require('request');\nvar stream = require('stream');\nvar parse = require('url').parse;\nvar format = require('url').format;\nvar zlib = require('zlib');\nvar config = require('./config');\n\nfunction makeRequest(payload, callback) {\n  var promise = new Promise(function (resolve, reject) {\n    var body = payload.body;\n    var bodyStream;\n\n    delete payload.body;\n\n    if (body) {\n      // always compress going upstream\n      bodyStream = new stream.Readable();\n      var json = JSON.stringify(body);\n      bodyStream.push(json);\n      bodyStream.push(null);\n\n      debug('compressing body (%s)', json.length);\n      if (json.length < 1e4) {\n        debug(JSON.stringify(body, '', 2));\n      }\n\n      if (!payload.headers) {\n        payload.headers = {};\n      }\n\n      payload.headers['content-encoding'] = 'gzip';\n    }\n\n    var url = parse(payload.url);\n\n    if (url.protocol === 'http:' && url.hostname !== 'localhost') {\n      debug('forcing api request to https');\n      url.protocol = 'https:';\n      payload.url = format(url);\n    }\n\n    // prefer config timeout unless payload specified\n    if (!payload.hasOwnProperty('timeout')) {\n      payload.timeout = config.timeout * 1000; // s -> ms\n    }\n\n    debug('request payload: ', JSON.stringify(payload));\n    var req = request(payload, function (error, res, body) {\n      debug(error);\n      debug('response (%s): ', (res || {}).statusCode, JSON.stringify(body));\n      if (error) {\n        return reject(error);\n      }\n\n      resolve({ res: res, body: body });\n    });\n\n    if (body) {\n      bodyStream.pipe(zlib.createGzip()).pipe(req);\n    }\n  });\n\n  // make callbacks and promises work\n  if (callback) {\n    promise.then(function (res) {\n      callback(null, res.res, res.body);\n    }).catch(callback);\n  }\n\n  return promise;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/is-ci.js":"var ciEnvs = [\n  'SNYK_CI',\n  'CI',\n  'CONTINUOUS_INTEGRATION',\n  'BUILD_ID',\n  'BUILD_NUMBER',\n  'TEAMCITY_VERSION',\n  'TRAVIS',\n  'CIRCLECI',\n  'JENKINS_URL',\n  'HUDSON_URL',\n  'bamboo.buildKey',\n  'PHPCI',\n  'GOCD_SERVER_HOST',\n  'BUILDKITE',\n  'TF_BUILD',\n];\n\nmodule.exports = !!Object.keys(process.env).filter(function (env) {\n  return ciEnvs.indexOf(env) !== -1;\n}).length;\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/module-info/index.js":"var detectFile = require('../detect').detectPackageFile;\n\nmodule.exports = function getModuleInfo(packageManager, root, options) {\n  var targetFile = options.file || detectFile(root);\n  var getInfo = loadModuleInfoForPackageManager(packageManager);\n  return getInfo(root, targetFile, options.policy);\n};\n\nfunction loadModuleInfoForPackageManager(packageManager) {\n  switch (packageManager) {\n    case 'npm': {\n      return require('./npm');\n    }\n    case 'rubygems': {\n      return require('./rubygems');\n    }\n    case 'maven': {\n      return require('./maven');\n    }\n    case 'yarn': {\n      return require('./yarn');\n    }\n    default: {\n      throw new Error('Unsupported package manager: ' + packageManager);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/spinner.js":"module.exports = createSpinner;\nmodule.exports.isRequired = true;\n\nvar debug = require('debug')('snyk:spinner');\nvar isCI = require('./is-ci');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar spinners = {};\nvar sticky = false;\nvar handleExit = false;\n\nfunction createSpinner(label) {\n  if (!label) {\n    throw new Error('spinner requires a label');\n  }\n\n  if (spinners[label] === undefined) {\n    spinners[label] = [];\n  }\n\n  // helper...\n  return new Promise(function (resolve) {\n    debug('spinner: %s', label);\n    spinners[label].push(spinner({\n      // string: '',\n      stream: sticky ? process.stdout : process.stderr,\n      interval: 75,\n      label: label,\n    }));\n\n    resolve();\n  });\n}\n\ncreateSpinner.sticky = function (s) {\n  sticky = s === undefined ? true : s;\n};\n\ncreateSpinner.clear = function (label) {\n  if (spinners[label] === undefined) {\n    throw new Error('unknown spinner label: ' + label);\n  }\n\n  return function (res) {\n    debug('clearing %s (%s)', label, spinners[label].length);\n    if (spinners[label].length) {\n      var s = spinners[label].pop();\n      if (s) {\n        s.clear();\n      }\n    }\n    return res;\n  };\n};\n\ncreateSpinner.clearAll = function () {\n  Object.keys(spinners).map(function (lbl) {\n    createSpinner.clear(lbl)();\n  });\n};\n\n// taken from http://git.io/vWdUm and modified\nfunction spinner(opt) {\n  if (module.exports.isRequired || isCI) {\n    return false;\n  }\n  debug('creating spinner');\n  if (!opt) {opt = {};}\n  var str = opt.stream || process.stderr;\n  var tty = typeof opt.tty === 'boolean' ? opt.tty : true;\n  var string = opt.string || '/-\\\\|';\n  var ms = typeof opt.interval === 'number' ? opt.interval : 50;\n  if (ms < 0) {ms = 0;}\n  if (tty && !str.isTTY) {return false;}\n  var CR = str.isTTY ? '\\u001b[0G' : '\\u000d';\n  var CLEAR = str.isTTY ? '\\u001b[2K' : '\\u000d \\u000d';\n\n  var s = 0;\n  var sprite = string.split('');\n  var wrote = false;\n\n  var delay = typeof opt.delay === 'number' ? opt.delay : 2;\n\n  var interval = setInterval(function () {\n    if (--delay >= 0) { return; }\n    s = ++s % sprite.length;\n    var c = sprite[s];\n    str.write(c + ' ' + (opt.label || '') + CR);\n    wrote = true;\n  }, ms);\n\n  var unref = typeof opt.unref === 'boolean' ? opt.unref : true;\n  if (unref && typeof interval.unref === 'function') {\n    interval.unref();\n  }\n\n  var cleanup = typeof opt.cleanup === 'boolean' ? opt.cleanup : true;\n  if (cleanup && !handleExit) {\n    handleExit = true;\n    process.on('exit', function () {\n      if (wrote) {\n        str.write(CLEAR);\n      }\n    });\n  }\n\n  spinner.clear = function () {\n    clearInterval(interval);\n    // debug('spinner cleared');\n    if (sticky) {\n      str.write(CLEAR);\n      str.write(opt.label + '\\n');\n    } else {\n      str.write(CLEAR);\n    }\n  };\n\n  return {\n    clear: spinner.clear,\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/monitor.js":"module.exports = monitor;\n\nvar snyk = require('..');\nvar apiTokenExists = require('./api-token').exists;\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar request = require('./request');\nvar config = require('./config');\nvar os = require('os');\nvar _ = require('../dist/lodash-min');\nvar isCI = require('./is-ci');\nvar analytics = require('./analytics');\n\nfunction monitor(root, meta, modules) {\n  var policyLocations = [root];\n  policyLocations = policyLocations.concat(pluckPolicies(modules));\n  var opts = { loose: true };\n  var packageManager = meta.packageManager || 'npm';\n  return apiTokenExists('snyk monitor')\n    .then(function () {\n      return snyk.policy.load(policyLocations, opts);\n    }).then(function (policy) {\n      analytics.add('packageManager', packageManager);\n      // YARN temporary fix to avoid BE changes\n      packageManager = packageManager === 'yarn' ? 'npm' : packageManager;\n      return new Promise(function (resolve, reject) {\n        request({\n          body: {\n            meta: {\n              method: meta.method,\n              hostname: os.hostname(),\n              id: meta.id || snyk.id || modules.name,\n              ci: isCI,\n              pid: process.pid,\n              node: process.version,\n              master: snyk.config.isMaster,\n              name: modules.name,\n              version: modules.version,\n              org: config.org ? decodeURIComponent(config.org) : undefined,\n            },\n            policy: policy.toString(),\n            package: modules,\n          },\n          gzip: true,\n          method: 'PUT',\n          headers: {\n            authorization: 'token ' + snyk.api,\n            'content-encoding': 'gzip',\n          },\n          url: config.API + '/monitor/' + packageManager,\n          json: true,\n        }, function (error, res, body) {\n          if (error) {\n            return reject(error);\n          }\n\n          if (res.statusCode === 200 || res.statusCode === 201) {\n            resolve(body);\n          } else {\n            var e = new Error('unexpected error: ' + body.message);\n            e.code = res.statusCode;\n            reject(e);\n          }\n        });\n      });\n    });\n}\n\nfunction pluckPolicies(pkg) {\n  if (!pkg) {\n    return null;\n  }\n\n  if (pkg.snyk) {\n    return pkg.snyk;\n  }\n\n  if (!pkg.dependencies) {\n    return null;\n  }\n\n  return _.flatten(Object.keys(pkg.dependencies).map(function (name) {\n    return pluckPolicies(pkg.dependencies[name]);\n  }).filter(Boolean));\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/dist/lodash-min.js":"/**\n * @license\n * lodash 3.10.1 (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE\n * Build: `lodash -p -o ./dist/lodash-min.js include=\"cloneDeep,extend,defaults,forEach,flatten,flattenDeep,merge,unique\"`\n */\n;(function(){function n(n,r,t){if(r!==r){n:{for(r=n.length,t+=-1;++t<r;){var e=n[t];if(e!==e){n=t;break n}}n=-1}return n}for(t-=1,e=n.length;++t<e;)if(n[t]===r)return t;return-1}function r(n){return!!n&&typeof n==\"object\"}function t(){}function e(n){var r=n?n.length:0;for(this.data={hash:ir(null),set:new ur};r--;)this.push(n[r])}function o(n,r){var t=n.data;return(typeof r==\"string\"||K(r)?t.set.has(r):t.hash[r])?0:-1}function u(n,r){var t=-1,e=n.length;for(r||(r=Array(e));++t<e;)r[t]=n[t];return r;\n}function c(n,r){for(var t=-1,e=n.length;++t<e&&false!==r(n[t],t,n););return n}function a(n,r){for(var t=-1,e=n.length;++t<e;)if(r(n[t],t,n))return true;return false}function i(n,r){return null==r?n:f(r,kr(r),n)}function f(n,r,t){t||(t={});for(var e=-1,o=r.length;++e<o;){var u=r[e];t[u]=n[u]}return t}function l(n,r,t){var e=typeof n;return\"function\"==e?r===an?n:O(n,r,t):null==n?on:\"object\"==e?j(n):r===an?cn(n):d(n,r)}function s(n,r,t,e,o,a,f){var l;if(t&&(l=o?t(n,e,o):t(n)),l!==an)return l;if(!K(n))return n;\nif(e=Or(n)){if(l=U(n),!r)return u(n,l)}else{var p=rr.call(n),h=p==gn;if(p!=jn&&p!=sn&&(!h||o))return Nn[p]?M(n,p,r):o?n:{};if(Jn(n))return o?n:{};if(l=F(h?{}:n),!r)return i(l,n)}for(a||(a=[]),f||(f=[]),o=a.length;o--;)if(a[o]==n)return f[o];return a.push(n),f.push(l),(e?c:y)(n,function(e,o){l[o]=s(e,r,t,o,n,a,f)}),l}function p(n,t,e,o){o||(o=[]);for(var u=-1,c=n.length;++u<c;){var a=n[u];if(r(a)&&C(a)&&(e||Or(a)||H(a)))if(t)p(a,t,e,o);else for(var i=o,f=-1,l=a.length,s=i.length;++f<l;)i[s+f]=a[f];else e||(o[o.length]=a);\n}return o}function h(n,r){mr(n,r,rn)}function y(n,r){return mr(n,r,kr)}function v(n,r,t){if(null!=n){n=R(n),t!==an&&t in n&&(r=[t]),t=0;for(var e=r.length;null!=n&&t<e;)n=R(n)[r[t++]];return t&&t==e?n:an}}function g(n,t,e,o,u,c){if(n===t)n=true;else if(null==n||null==t||!K(n)&&!r(t))n=n!==n&&t!==t;else n:{var a=g,i=Or(n),f=Or(t),l=pn,s=pn;i||(l=rr.call(n),l==sn?l=jn:l!=jn&&(i=Z(n))),f||(s=rr.call(t),s==sn?s=jn:s!=jn&&Z(t));var p=l==jn&&!Jn(n),f=s==jn&&!Jn(t),s=l==s;if(!s||i||p){if(!o&&(l=p&&nr.call(n,\"__wrapped__\"),\nf=f&&nr.call(t,\"__wrapped__\"),l||f)){n=a(l?n.value():n,f?t.value():t,e,o,u,c);break n}if(s){for(u||(u=[]),c||(c=[]),l=u.length;l--;)if(u[l]==n){n=c[l]==t;break n}u.push(n),c.push(t),n=(i?E:I)(n,t,a,e,o,u,c),u.pop(),c.pop()}else n=false}else n=k(n,t,l)}return n}function b(n,r){var t=r.length,e=t;if(null==n)return!e;for(n=R(n);t--;){var o=r[t];if(o[2]?o[1]!==n[o[0]]:!(o[0]in n))return false}for(;++t<e;){var o=r[t],u=o[0],c=n[u],a=o[1];if(o[2]){if(c===an&&!(u in n))return false}else if(o=an,o===an?!g(a,c,void 0,true):!o)return false;\n}return true}function j(n){var r=_(n);if(1==r.length&&r[0][2]){var t=r[0][0],e=r[0][1];return function(n){return null==n?false:(n=R(n),n[t]===e&&(e!==an||t in n))}}return function(n){return b(n,r)}}function d(n,r){var t=Or(n),e=B(n)&&r===r&&!K(r),o=n+\"\";return n=q(n),function(u){if(null==u)return false;var c=o;if(u=R(u),!(!t&&e||c in u)){if(1!=n.length){var c=n,a=0,i=-1,f=-1,l=c.length,a=null==a?0:+a||0;for(0>a&&(a=-a>l?0:l+a),i=i===an||i>l?l:+i||0,0>i&&(i+=l),l=a>i?0:i-a>>>0,a>>>=0,i=Array(l);++f<l;)i[f]=c[f+a];\nu=v(u,i)}if(null==u)return false;c=V(n),u=R(u)}return u[c]===r?r!==an||c in u:g(r,u[c],an,true)}}function m(n,t,e,o,a){if(!K(n))return n;var i=C(t)&&(Or(t)||Z(t)),f=i?an:kr(t);return c(f||t,function(c,l){if(f&&(l=c,c=t[l]),r(c)){o||(o=[]),a||(a=[]);n:{for(var s=l,p=o,h=a,y=p.length,v=t[s];y--;)if(p[y]==v){n[s]=h[y];break n}var y=n[s],g=e?e(y,v,s,n,t):an,b=g===an;b&&(g=v,C(v)&&(Or(v)||Z(v))?g=Or(y)?y:C(y)?u(y):[]:X(v)||H(v)?g=H(y)?nn(y):X(y)?y:{}:b=false),p.push(v),h.push(g),b?n[s]=m(g,v,e,p,h):(g===g?g!==y:y===y)&&(n[s]=g);\n}}else s=n[l],p=e?e(s,c,l,n,t):an,(h=p===an)&&(p=c),p===an&&(!i||l in n)||!h&&(p===p?p===s:s!==s)||(n[l]=p)}),n}function w(n){return function(r){return null==r?an:R(r)[n]}}function A(n){var r=n+\"\";return n=q(n),function(t){return v(t,n,r)}}function O(n,r,t){if(typeof n!=\"function\")return on;if(r===an)return n;switch(t){case 1:return function(t){return n.call(r,t)};case 3:return function(t,e,o){return n.call(r,t,e,o)};case 4:return function(t,e,o,u){return n.call(r,t,e,o,u)};case 5:return function(t,e,o,u,c){\nreturn n.call(r,t,e,o,u,c)}}return function(){return n.apply(r,arguments)}}function x(n){var r=new er(n.byteLength);return new ar(r).set(new ar(n)),r}function S(n){return G(function(r,t){var e=-1,o=null==r?0:t.length,u=2<o?t[o-2]:an,c=2<o?t[2]:an,a=1<o?t[o-1]:an;for(typeof u==\"function\"?(u=O(u,a,5),o-=2):(u=typeof a==\"function\"?a:an,o-=u?1:0),c&&T(t[0],t[1],c)&&(u=3>o?an:u,o=1);++e<o;)(c=t[e])&&n(r,c,u);return r})}function E(n,r,t,e,o,u,c){var i=-1,f=n.length,l=r.length;if(f!=l&&(!o||l<=f))return false;\nfor(;++i<f;){var s=n[i],l=r[i],p=e?e(o?l:s,o?s:l,i):an;if(p!==an){if(p)continue;return false}if(o){if(!a(r,function(n){return s===n||t(s,n,e,o,u,c)}))return false}else if(s!==l&&!t(s,l,e,o,u,c))return false}return true}function k(n,r,t){switch(t){case hn:case yn:return+n==+r;case vn:return n.name==r.name&&n.message==r.message;case bn:return n!=+n?r!=+r:n==+r;case dn:case mn:return n==r+\"\"}return false}function I(n,r,t,e,o,u,c){var a=kr(n),i=a.length,f=kr(r).length;if(i!=f&&!o)return false;for(f=i;f--;){var l=a[f];if(!(o?l in r:nr.call(r,l)))return false;\n}for(var s=o;++f<i;){var l=a[f],p=n[l],h=r[l],y=e?e(o?h:p,o?p:h,l):an;if(y===an?!t(p,h,e,o,u,c):!y)return false;s||(s=\"constructor\"==l)}return s||(t=n.constructor,e=r.constructor,!(t!=e&&\"constructor\"in n&&\"constructor\"in r)||typeof t==\"function\"&&t instanceof t&&typeof e==\"function\"&&e instanceof e)?true:false}function P(){var r=t.indexOf||W;return r=r===W?n:r}function _(n){n=tn(n);for(var r=n.length;r--;){var t=n[r][1];n[r][2]=t===t&&!K(t)}return n}function $(n,r){var t=null==n?an:n[r];return Q(t)?t:an}\nfunction U(n){var r=n.length,t=new n.constructor(r);return r&&\"string\"==typeof n[0]&&nr.call(n,\"index\")&&(t.index=n.index,t.input=n.input),t}function F(n){return n=n.constructor,typeof n==\"function\"&&n instanceof n||(n=Object),new n}function M(n,r,t){var e=n.constructor;switch(r){case wn:return x(n);case hn:case yn:return new e(+n);case An:case On:case xn:case Sn:case En:case kn:case In:case Pn:case _n:return e instanceof e&&(e=br[r]),r=n.buffer,new e(t?x(r):r,n.byteOffset,n.length);case bn:case mn:\nreturn new e(n);case dn:var o=new e(n.source,Cn.exec(n));o.lastIndex=n.lastIndex}return o}function C(n){return null!=n&&D(wr(n))}function L(n,r){return n=typeof n==\"number\"||Tn.test(n)?+n:-1,r=null==r?gr:r,-1<n&&0==n%1&&n<r}function T(n,r,t){if(!K(t))return false;var e=typeof r;return(\"number\"==e?C(t)&&L(r,t.length):\"string\"==e&&r in t)?(r=t[r],n===n?n===r:r!==r):false}function B(n){var r=typeof n;return\"string\"==r&&Un.test(n)||\"number\"==r?true:Or(n)?false:!$n.test(n)||false}function D(n){return typeof n==\"number\"&&-1<n&&0==n%1&&n<=gr;\n}function N(n){for(var r=rn(n),t=r.length,e=t&&n.length,o=!!e&&D(e)&&(Or(n)||H(n)||Y(n)),u=-1,c=[];++u<t;){var a=r[u];(o&&L(a,e)||nr.call(n,a))&&c.push(a)}return c}function R(n){if(t.support.unindexedChars&&Y(n)){for(var r=-1,e=n.length,o=Object(n);++r<e;)o[r]=n.charAt(r);return o}return K(n)?n:Object(n)}function q(n){if(Or(n))return n;var r=[];return(null==n?\"\":n+\"\").replace(Fn,function(n,t,e,o){r.push(e?o.replace(Mn,\"$1\"):t||n)}),r}function W(r,t,e){var o=r?r.length:0;if(!o)return-1;if(typeof e==\"number\")e=0>e?pr(o+e,0):e;else if(e){\ne=0;var u=r?r.length:e;if(typeof t!=\"number\"||t!==t||u>vr){u=on,e=u(t);for(var c=0,a=r?r.length:0,i=e!==e,f=null===e,l=e===an;c<a;){var s=fr((c+a)/2),p=u(r[s]),h=p!==an,y=p===p;(i?y:f?y&&h&&null!=p:l?y&&h:null==p?0:p<e)?c=s+1:a=s}e=hr(a,yr)}else{for(;e<u;){var c=e+u>>>1,a=r[c];a<t&&null!==a?e=c+1:u=c}e=u}return e<o&&(t===t?t===r[e]:r[e]!==r[e])?e:-1}return n(r,t,e||0)}function V(n){var r=n?n.length:0;return r?n[r-1]:an}function z(r,u,c,a){if(!r||!r.length)return[];null!=u&&typeof u!=\"boolean\"&&(a=c,\nc=T(r,u,a)?an:u,u=false);var i;if(i=t.callback||en,i=i===en?l:i,(null!=c||i!==l)&&(c=i(c,a,3)),u&&P()===n){u=c;var f;c=-1,a=r.length,i=-1;for(var s=[];++c<a;){var p=r[c],h=u?u(p,c,r):p;c&&f===h||(f=h,s[++i]=p)}r=s}else{f=c,u=-1,c=P(),a=r.length,p=(s=(i=c===n)&&a>=fn)&&ir&&ur?new e(void 0):null,h=[],p?(c=o,i=false):(s=false,p=f?[]:h);n:for(;++u<a;){var y=r[u],v=f?f(y,u,r):y;if(i&&y===y){for(var g=p.length;g--;)if(p[g]===v)continue n;f&&p.push(v),h.push(y)}else 0>c(p,v,0)&&((f||s)&&p.push(v),h.push(y))}r=h}\nreturn r}function G(n,r){if(typeof n!=\"function\")throw new TypeError(ln);return r=pr(r===an?n.length-1:+r||0,0),function(){for(var t=arguments,e=-1,o=pr(t.length-r,0),u=Array(o);++e<o;)u[e]=t[r+e];switch(r){case 0:return n.call(this,u);case 1:return n.call(this,t[0],u);case 2:return n.call(this,t[0],t[1],u)}for(o=Array(r+1),e=-1;++e<r;)o[e]=t[e];return o[r]=u,n.apply(this,o)}}function H(n){return r(n)&&C(n)&&nr.call(n,\"callee\")&&!or.call(n,\"callee\")}function J(n){return K(n)&&rr.call(n)==gn}function K(n){\nvar r=typeof n;return!!n&&(\"object\"==r||\"function\"==r)}function Q(n){return null==n?false:J(n)?tr.test(Zn.call(n)):r(n)&&(Jn(n)?tr:Ln).test(n)}function X(n){var e;if(!r(n)||rr.call(n)!=jn||Jn(n)||H(n)||!(nr.call(n,\"constructor\")||(e=n.constructor,typeof e!=\"function\"||e instanceof e)))return false;var o;return t.support.ownLast?(h(n,function(n,r,t){return o=nr.call(t,r),false}),false!==o):(h(n,function(n,r){o=r}),o===an||nr.call(n,o))}function Y(n){return typeof n==\"string\"||r(n)&&rr.call(n)==mn}function Z(n){\nreturn r(n)&&D(n.length)&&!!Dn[rr.call(n)]}function nn(n){return f(n,rn(n))}function rn(n){if(null==n)return[];K(n)||(n=Object(n));for(var r=n.length,e=t.support,r=r&&D(r)&&(Or(n)||H(n)||Y(n))&&r||0,o=n.constructor,u=-1,o=J(o)&&o.prototype||Xn,c=o===n,a=Array(r),i=0<r,f=e.enumErrorProps&&(n===Qn||n instanceof Error),l=e.enumPrototypes&&J(n);++u<r;)a[u]=u+\"\";for(var s in n)l&&\"prototype\"==s||f&&(\"message\"==s||\"name\"==s)||i&&L(s,r)||\"constructor\"==s&&(c||!nr.call(n,s))||a.push(s);if(e.nonEnumShadows&&n!==Xn)for(r=n===Yn?mn:n===Qn?vn:rr.call(n),\ne=jr[r]||jr[jn],r==jn&&(o=Xn),r=Bn.length;r--;)s=Bn[r],u=e[s],c&&u||(u?!nr.call(n,s):n[s]===o[s])||a.push(s);return a}function tn(n){n=R(n);for(var r=-1,t=kr(n),e=t.length,o=Array(e);++r<e;){var u=t[r];o[r]=[u,n[u]]}return o}function en(n,t,e){return e&&T(n,t,e)&&(t=an),r(n)?un(n):l(n,t)}function on(n){return n}function un(n){return j(s(n,true))}function cn(n){return B(n)?w(n):A(n)}var an,fn=200,ln=\"Expected a function\",sn=\"[object Arguments]\",pn=\"[object Array]\",hn=\"[object Boolean]\",yn=\"[object Date]\",vn=\"[object Error]\",gn=\"[object Function]\",bn=\"[object Number]\",jn=\"[object Object]\",dn=\"[object RegExp]\",mn=\"[object String]\",wn=\"[object ArrayBuffer]\",An=\"[object Float32Array]\",On=\"[object Float64Array]\",xn=\"[object Int8Array]\",Sn=\"[object Int16Array]\",En=\"[object Int32Array]\",kn=\"[object Uint8Array]\",In=\"[object Uint8ClampedArray]\",Pn=\"[object Uint16Array]\",_n=\"[object Uint32Array]\",$n=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,Un=/^\\w*$/,Fn=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g,Mn=/\\\\(\\\\)?/g,Cn=/\\w*$/,Ln=/^\\[object .+?Constructor\\]$/,Tn=/^\\d+$/,Bn=\"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \"),Dn={};\nDn[An]=Dn[On]=Dn[xn]=Dn[Sn]=Dn[En]=Dn[kn]=Dn[In]=Dn[Pn]=Dn[_n]=true,Dn[sn]=Dn[pn]=Dn[wn]=Dn[hn]=Dn[yn]=Dn[vn]=Dn[gn]=Dn[\"[object Map]\"]=Dn[bn]=Dn[jn]=Dn[dn]=Dn[\"[object Set]\"]=Dn[mn]=Dn[\"[object WeakMap]\"]=false;var Nn={};Nn[sn]=Nn[pn]=Nn[wn]=Nn[hn]=Nn[yn]=Nn[An]=Nn[On]=Nn[xn]=Nn[Sn]=Nn[En]=Nn[bn]=Nn[jn]=Nn[dn]=Nn[mn]=Nn[kn]=Nn[In]=Nn[Pn]=Nn[_n]=true,Nn[vn]=Nn[gn]=Nn[\"[object Map]\"]=Nn[\"[object Set]\"]=Nn[\"[object WeakMap]\"]=false;var Rn={\"function\":true,object:true},qn=Rn[typeof exports]&&exports&&!exports.nodeType&&exports,Wn=Rn[typeof module]&&module&&!module.nodeType&&module,Vn=Rn[typeof self]&&self&&self.Object&&self,zn=Rn[typeof window]&&window&&window.Object&&window,Gn=Wn&&Wn.exports===qn&&qn,Hn=qn&&Wn&&typeof global==\"object\"&&global&&global.Object&&global||zn!==(this&&this.window)&&zn||Vn||this,Jn=function(){\ntry{Object({toString:0}+\"\")}catch(n){return function(){return false}}return function(n){return typeof n.toString!=\"function\"&&typeof(n+\"\")==\"string\"}}(),Kn=Array.prototype,Qn=Error.prototype,Xn=Object.prototype,Yn=String.prototype,Zn=Function.prototype.toString,nr=Xn.hasOwnProperty,rr=Xn.toString,tr=RegExp(\"^\"+Zn.call(nr).replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),er=Hn.ArrayBuffer,or=Xn.propertyIsEnumerable,ur=$(Hn,\"Set\"),cr=Kn.splice,ar=Hn.Uint8Array,ir=$(Object,\"create\"),fr=Math.floor,lr=$(Array,\"isArray\"),sr=$(Object,\"keys\"),pr=Math.max,hr=Math.min,yr=4294967294,vr=2147483647,gr=9007199254740991,br={};\nbr[An]=Hn.Float32Array,br[On]=Hn.Float64Array,br[xn]=Hn.Int8Array,br[Sn]=Hn.Int16Array,br[En]=Hn.Int32Array,br[kn]=ar,br[In]=Hn.Uint8ClampedArray,br[Pn]=Hn.Uint16Array,br[_n]=Hn.Uint32Array;var jr={};jr[pn]=jr[yn]=jr[bn]={constructor:true,toLocaleString:true,toString:true,valueOf:true},jr[hn]=jr[mn]={constructor:true,toString:true,valueOf:true},jr[vn]=jr[gn]=jr[dn]={constructor:true,toString:true},jr[jn]={constructor:true},c(Bn,function(n){for(var r in jr)if(nr.call(jr,r)){var t=jr[r];t[n]=nr.call(t,n)}});var dr=t.support={};\n!function(n){function r(){this.x=n}var t={0:n,length:n},e=[];r.prototype={valueOf:n,y:n};for(var o in new r)e.push(o);dr.enumErrorProps=or.call(Qn,\"message\")||or.call(Qn,\"name\"),dr.enumPrototypes=or.call(r,\"prototype\"),dr.nonEnumShadows=!/valueOf/.test(e),dr.ownLast=\"x\"!=e[0],dr.spliceObjects=(cr.call(t,0,1),!t[0]),dr.unindexedChars=\"xx\"!=\"x\"[0]+Object(\"x\")[0]}(1,0);var mr=function(n){return function(r,t,e){var o=R(r);e=e(r);for(var u=e.length,c=n?u:-1;n?c--:++c<u;){var a=e[c];if(false===t(o[a],a,o))break;\n}return r}}(),wr=w(\"length\"),Ar=function(n,r){return function(t,e,o){return typeof e==\"function\"&&o===an&&Or(t)?n(t,e):r(t,O(e,o,3))}}(c,function(n,r){return function(t,e){var o=t?wr(t):0;if(!D(o))return n(t,e);for(var u=r?o:-1,c=R(t);(r?u--:++u<o)&&false!==e(c[u],u,c););return t}}(y)),Or=lr||function(n){return r(n)&&D(n.length)&&rr.call(n)==pn},xr=S(m),Sr=S(function(n,r,t){if(t)for(var e=-1,o=kr(r),u=o.length;++e<u;){var c=o[e],a=n[c],f=t(a,r[c],c,n,r);(f===f?f===a:a!==a)&&(a!==an||c in n)||(n[c]=f);\n}else n=i(n,r);return n}),Er=function(n,r){return G(function(t){var e=t[0];return null==e?e:(t.push(r),n.apply(an,t))})}(Sr,function(n,r){return n===an?r:n}),kr=sr?function(n){var r=null==n?an:n.constructor;return typeof r==\"function\"&&r.prototype===n||(typeof n==\"function\"?t.support.enumPrototypes:C(n))?N(n):K(n)?sr(n):[]}:N;e.prototype.push=function(n){var r=this.data;typeof n==\"string\"||K(n)?r.set.add(n):r.hash[n]=true},t.assign=Sr,t.callback=en,t.defaults=Er,t.flatten=function(n,r,t){var e=n?n.length:0;\nreturn t&&T(n,r,t)&&(r=false),e?p(n,r):[]},t.flattenDeep=function(n){return n&&n.length?p(n,true):[]},t.forEach=Ar,t.keys=kr,t.keysIn=rn,t.matches=un,t.merge=xr,t.pairs=tn,t.property=cn,t.restParam=G,t.toPlainObject=nn,t.uniq=z,t.each=Ar,t.extend=Sr,t.iteratee=en,t.unique=z,t.cloneDeep=function(n,r,t){return typeof r==\"function\"?s(n,true,O(r,t,3)):s(n,true)},t.identity=on,t.indexOf=W,t.isArguments=H,t.isArray=Or,t.isFunction=J,t.isNative=Q,t.isObject=K,t.isPlainObject=X,t.isString=Y,t.isTypedArray=Z,t.last=V,\nt.VERSION=\"3.10.1\",typeof define==\"function\"&&typeof define.amd==\"object\"&&define.amd?(Hn._=t, define(function(){return t})):qn&&Wn?Gn?(Wn.exports=t)._=t:qn._=t:Hn._=t}).call(this);","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/bus.js":"var events = require('events');\nvar util = require('util');\n\nfunction Bus() {\n  events.EventEmitter.call(this);\n}\n\nutil.inherits(Bus, events.EventEmitter);\nmodule.exports = new Bus();","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/index.js":"var fs = require('then-fs');\nvar path = require('path');\nvar debug = require('debug')('snyk:policy');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar match = require('./match');\nvar parse = require('./parser');\nvar tryRequire = require('snyk-try-require');\nvar filter = require('./filter');\nvar add = require('./add');\n\nmodule.exports = {\n  filter: filter,\n  demunge: parse.demunge,\n  load: load,\n  save: save,\n  getByVuln: match.getByVuln,\n  matchToRule: match.matchToRule,\n  loadFromText: loadFromText,\n  add: add,\n  create: create,\n};\n\nfunction create() {\n  return loadFromText('');\n}\n\n// this is a function to allow our tests and fixtures to change cwd\nfunction defaultFilename() {\n  return path.resolve(process.cwd(), '.snyk');\n}\n\nfunction attachMethods(policy) {\n  policy.filter = function (vulns, root) {\n    return filter(vulns, policy, root || path.dirname(policy.__filename));\n  };\n  policy.save = save.bind(null, policy);\n  policy.toString = parse.export.bind(null, policy);\n  policy.demunge = parse.demunge.bind(null, policy);\n  policy.add = add.bind(null, policy);\n  policy.addIgnore = add.bind(null, policy, 'ignore');\n  policy.addPatch = add.bind(null, policy, 'patch');\n  return policy;\n}\n\nfunction loadFromText(text) {\n  return new Promise(function (resolve) {\n    var policy = parse.import(text);\n    var now = Date.now();\n\n    policy.__filename = '';\n    policy.__modified = now;\n    policy.__created = now;\n\n    resolve(policy);\n  }).then(attachMethods);\n}\n\nfunction load(root, options) {\n  if (!Array.isArray(root) && typeof root !== 'string') {\n    options = root;\n    root = null;\n  }\n\n  if (!root) {\n    root = process.cwd();\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  var ignorePolicy = !!options['ignore-policy'];\n\n  var filename = '';\n  if (Array.isArray(root)) {\n    // we do a bit of a dance to get the first item in the array, and\n    // use it as our filename\n    filename = root[0];\n  } else {\n    if (root.indexOf('.snyk') === -1) {\n      root = path.resolve(root, '.snyk');\n    }\n    filename = root;\n  }\n\n  if (filename.indexOf('.snyk') === -1) {\n    filename = path.resolve(filename, '.snyk');\n  }\n\n  var promise = new Promise(function (resolve) {\n    if (ignorePolicy) {\n      return resolve(parse.import());\n    }\n\n    if (!ignorePolicy && Array.isArray(root)) {\n      return resolve(mergePolicies(root, options).then(function (res) {\n        debug('final policy:');\n        debug(JSON.stringify(res, '', 2));\n        return res;\n      }));\n    }\n\n    resolve(fs.readFile(filename, 'utf8').then(parse.import));\n  });\n\n  var promises = [\n    promise,\n    fs.stat(filename).catch(function () {\n      return {};\n    }),\n  ];\n\n  return Promise.all(promises).catch(function (error) {\n    if (options.loose && error.code === 'ENOENT') {\n      debug('ENOENT on file, but running loose');\n      return [parse.import(), {}];\n    }\n\n    throw error;\n  }).then(function (res) {\n    var policy = res[0];\n\n    policy.__modified = res[1].mtime;\n    policy.__created = res[1].birthtime || res[1].ctime;\n\n    if (options.loose && !policy.__modified) {\n      policy.__filename = null;\n    } else {\n      policy.__filename = path.relative(process.cwd(), filename);\n    }\n\n    return policy;\n  }).then(attachMethods);\n}\n\nfunction mergePolicies(policyDirs, options) {\n  var ignoreTarget = options['trust-policies'] ? 'ignore' : 'suggest';\n\n  return Promise.all(policyDirs.map(function (dir) {\n    return load(dir, options);\n  })).then(function (policies) {\n    // firstly extend the paths in the ignore and patch\n    var rootPolicy = policies[0];\n    var others = policies.slice(1);\n\n    return Promise.all(others.filter(function (policy) {\n      return policy.__filename; // filter out non loaded policies\n    }).map(function (policy) {\n      var filename = path.dirname(policy.__filename) + '/package.json';\n\n      return tryRequire(filename).then(function (pkg) {\n        var full = pkg.name + '@' + pkg.version;\n\n        mergePath('ignore', ignoreTarget, full, rootPolicy, policy);\n        mergePath('patch', 'patch', full, rootPolicy, policy);\n      });\n    })).then(function () {\n      return rootPolicy;\n    });\n  });\n}\n\n// note: mutates both objects, be warned!\nfunction mergePath(type, into, pathRoot, rootPolicy, policy) {\n  if (!rootPolicy[into]) {\n    rootPolicy[into] = {};\n  }\n\n  Object.keys(policy[type]).forEach(function (id) {\n    // convert the path from `module@version` to `parent > module@version`\n    policy[type][id] = policy[type][id].map(function (path) {\n      // this is because our policy file format favours \"readable\" yaml,\n      // instead of easy to use object structures.\n      var key = Object.keys(path).pop();\n      var newPath = {};\n      newPath[pathRoot + ' > ' + key] = path[key];\n      path[key].from = pathRoot;\n      return newPath;\n    });\n\n    // add the rule if we don't have it in our policy already\n    if (!rootPolicy[into][id]) {\n      rootPolicy[into][id] = policy[type][id];\n      return;\n    }\n\n    // otherwise we need to merge up manually\n    rootPolicy[into][id] = rootPolicy[into][id].concat(policy[type][id]);\n  });\n}\n\nfunction save(object, root, spinner) {\n  var filename = root ?\n    path.resolve(root, '.snyk') :\n    defaultFilename();\n\n  var lbl = 'Saving .snyk policy file...';\n\n  if (!spinner) {\n    spinner = function (res) {\n      return Promise.resolve(res);\n    };\n    spinner.clear = spinner;\n  }\n\n  return spinner(lbl).then(function () {\n    return parse.export(object);\n  }).then(function (yaml) {\n    return fs.writeFile(filename, yaml);\n  }).then(spinner.clear(lbl));\n}\n\n/* istanbul ignore if */\nif (!module.parent) {\n  load(process.argv[2]).then(function (res) {\n    console.log(JSON.stringify(res, '', 2));\n  }).catch(function (e) {\n    console.log(e.stack);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/match.js":"module.exports = {\n  matchToRule: matchToRule,\n  getByVuln: getByVuln,\n};\n\nvar debug = require('debug')('snyk:policy');\nvar debugPolicy = require('debug')('snyk:protect');\nvar semver = require('semver');\nvar moduleToObject = require('snyk-module');\n\n// matchPath will take the array of dependencies that a vulnerability came from\n// and try to match it to a string `path`. The path will look like this:\n// express-hbs@0.8.4 > handlebars@3.0.3 > uglify-js@2.3.6\n// note that the root package is never part of the path (i.e. jsbin@3.11.31)\n// the path can also use `*` as a wildcard _and_ use semver:\n// * > uglify-js@2.x\n// The matchPath will break the `path` down into it's component parts, and loop\n// through trying to get a positive match or not. For full examples of options\n// see http://git.io/vCH3N\nfunction matchPath(from, path) {\n  var parts = path.split(' > ');\n  debugPolicy('checking path: %s vs. %s', path, from);\n  var offset = 0;\n  var res = parts.every(function (pkg, i) {\n    debugPolicy('for %s...(against %s)', pkg, from[i + offset]);\n    var fromPkg = from[i + offset] ? moduleToObject(from[i + offset]) : {};\n\n    if (pkg === '*') {\n      debugPolicy('star rule');\n\n      // handle the rule being `*` alone\n      if (!parts[i + 1]) {\n        return true;\n      }\n\n      var next = moduleToObject(parts[i + 1]);\n\n      // assuming we're not at the end of the rule path, then try to find\n      // the next matching package in the chain. So `* > semver` matches\n      // `foo > bar > semver`\n      if (next) {\n        debugPolicy('next', next);\n        // move forward until we find a matching package\n        for (var j = i; i < parts.length; j++) {\n          // if we've run out of paths, then we didn't match\n          if (!from[i + offset]) {\n            return false;\n          }\n          fromPkg = moduleToObject(from[i + offset]);\n          debugPolicy('fromPkg', fromPkg, next);\n\n          if (next.name === fromPkg.name) {\n            // adjust for the `i` index incrementing in the next .every call\n            offset--;\n            debugPolicy('next has a match');\n            break;\n          }\n          debugPolicy('pushing offset');\n          offset++;\n        }\n      }\n\n      return true;\n    }\n\n    debugPolicy('next test', pkg, fromPkg);\n\n    if (pkg === from[i + offset]) {\n      debugPolicy('exact match');\n      return true;\n    }\n\n    // if we're missing the @version - add @* so the pkg is foobar@*\n    // so we have a good semver range\n    if (pkg.indexOf('@') === -1) {\n      pkg += '@*';\n    }\n\n    var target = moduleToObject(pkg);\n\n    var pkgVersion = target.version;\n\n    // the * semver rule won't match pre-releases, which in our case is a\n    // problem, so if the version is indeed *, we'll reset it to the exact same\n    // version as our target package to allow for a match.\n    if (pkgVersion === '*') {\n      pkgVersion = fromPkg.version;\n    }\n\n    // shortcut version match, if it's exact, then skip the semver check\n    if (target.name === fromPkg.name) {\n      if (fromPkg.version === pkgVersion) {\n        debugPolicy('exact version match');\n        return true;\n      }\n\n      if (semver.valid(fromPkg.version) &&\n        semver.satisfies(fromPkg.version, pkgVersion)) {\n        debugPolicy('semver match');\n        return true;\n      }\n    }\n\n\n    debugPolicy('failed match');\n\n    return false;\n  });\n  debugPolicy('result of path test %s: %s', path, res);\n  return res;\n}\n\nfunction matchToRule(vuln, rule) {\n  return Object.keys(rule).some(function (path) {\n    return matchToSingleRule(vuln, path);\n  });\n}\n\nfunction matchToSingleRule(vuln, path) {\n  // check for an exact match\n  var pathMatch = false;\n  var from = vuln.from.slice(1);\n  if (path.indexOf(from.join(' > ')) !== -1) {\n    debug('%s exact match from %s', vuln.id, from);\n    pathMatch = true;\n  } else if (matchPath(from, path)) {\n    pathMatch = true;\n  }\n\n  return pathMatch;\n}\n\nfunction getByVuln(policy, vuln) {\n  var found = null;\n\n  if (!policy || !vuln) {\n    return found;\n  }\n\n  ['ignore', 'patch'].forEach(function (key) {\n    Object.keys(policy[key] || []).forEach(function (p) {\n      if (p === vuln.id) {\n        policy[key][p].forEach(function (rule) {\n          if (matchToRule(vuln, rule)) {\n            found = {\n              type: key,\n              id: vuln.id,\n              rule: vuln.from,\n            };\n            var rootRule = Object.keys(rule).pop();\n            Object.keys(rule[rootRule]).forEach(function (key) {\n              found[key] = rule[rootRule][key];\n            });\n          }\n        });\n      }\n    });\n  });\n\n  return found;\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/parser/index.js":"var path = require('path');\nvar cloneDeep = require('lodash.clonedeep');\nvar semver = require('semver');\nvar yaml = require('js-yaml');\nvar addComments = require('./add-comments');\n\nmodule.exports = {\n  import: imports,\n  export: exports,\n  demunge: require('./demunge'),\n  version: version(),\n};\n\nvar parsers = {\n  v1: require('./v1'),\n};\n\nfunction imports(rawYaml) {\n  var data = yaml.safeLoad(rawYaml || '');\n\n  if (!data || typeof data !== 'object') {\n    data = {};\n  }\n\n  if (!data.version) {\n    data.version = version();\n  }\n\n  if (data.version === 'v1') {\n    data.version = 'v1.0.0';\n  }\n\n  var parser = parsers['v' + semver.major(data.version.substr(1))];\n\n  if (!parser) {\n    throw new Error('unsupported version: ' + data.version);\n  }\n\n  return parser(data);\n}\n\nfunction exports(policy) {\n  var data = cloneDeep(policy);\n\n  // remove any private information on the policy\n  Object.keys(data).map(function (key) {\n    if (key.indexOf('__') === 0) {\n      delete data[key];\n    }\n\n    if (data[key] == null) { // jshint ignore:line\n      delete data[key];\n    }\n\n    // strip helper functions\n    if (typeof data[key] === 'function') {\n      delete data[key];\n    }\n  });\n\n  // ensure we always update the version of the policy format\n  data.version = version();\n  // put inline comments into the exported yaml file\n  return addComments(yaml.safeDump(data));\n}\n\nfunction version() {\n  var filename = path.resolve(__dirname, '..', '..', 'package.json');\n  var version = require(filename).version;\n\n  if (version && version !== '0.0.0') {\n    return 'v' + version;\n  }\n\n  return 'v1.0.0';\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/parser/add-comments.js":"module.exports = addComments;\n\nvar initialComment = '# Snyk (https://snyk.io) policy file, patches or ' +\n                     'ignores known vulnerabilities.';\nvar inlineComments = {\n  ignore: '# ignores vulnerabilities until expiry date; change duration by ' +\n          'modifying expiry date',\n  patch: '# patches apply the minimum changes required to fix a vulnerability',\n};\n\nfunction addComments(policyExport) {\n  var lines = policyExport.split('\\n');\n  lines.unshift(initialComment);\n\n  Object.keys(inlineComments).forEach(function (key) {\n    var position = lines.indexOf(key + ':');\n    if (position !== -1) {\n      lines.splice(position, 0, inlineComments[key]);\n    }\n  });\n\n  return lines.join('\\n');\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/parser/demunge.js":"module.exports = demunge;\n\nfunction demunge(policy, apiRoot) {\n  if (!apiRoot) {\n    apiRoot = '';\n  }\n\n  var res = ['ignore', 'patch'].reduce(function (acc, type) {\n    acc[type] = policy[type] ? Object.keys(policy[type]).map(function (id) {\n      var paths = policy[type][id].map(function (pathObj) {\n        var path = Object.keys(pathObj).pop();\n        var res = {\n          path: path,\n        };\n        if (type === 'ignore') {\n          res.reason = pathObj[path].reason;\n          res.expires = new Date(pathObj[path].expires);\n        }\n\n        return res;\n      });\n      return {\n        id: id,\n        url: apiRoot + '/vuln/' + id,\n        paths: paths,\n      };\n    }) : [];\n    return acc;\n  }, {});\n\n  res.version = policy.version;\n\n  return res;\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/parser/v1.js":"// eventually we'll have v2 which will point to latestParser, and v1 will\n// need to process the old form of data and upgrade it to v2 structure\nmodule.exports = function imports(policy) {\n  if (!policy.ignore) {\n    policy.ignore = {};\n  }\n\n  if (!policy.patch) {\n    policy.patch = {};\n  }\n\n  checkForOldFormat(policy.ignore); // this is only an old issue on ignores\n  validate(policy.ignore);\n  validate(policy.patch);\n\n  policy.failThreshold = getFailThreshold(policy);\n  if (!policy.failThreshold) { // throw it away if it's not set\n    delete policy.failThreshold;\n  }\n\n  return policy;\n};\n\nmodule.exports.needsFixing = needsFixing;\n\nfunction checkForOldFormat(ignore) {\n  // this is a cursory test to ensure that we're working with a snyk format\n  // that we recognise. if the property is an object, then it's the early\n  // alpha format, and we'll throw\n  Object.keys(ignore).forEach(function (id) {\n    if (!Array.isArray(ignore[id])) {\n      var error = new Error('old, unsupported .snyk format detected');\n      error.code = 'OLD_DOTFILE_FORMAT';\n      throw error;\n    }\n  });\n}\n\nfunction validate(policy) {\n  var fix = needsFixing(policy);\n\n  if (fix) {\n    fix.forEach(function (item) {\n      var o = {};\n      o[item.key] = item.rule;\n      policy[item.id].push(o);\n    });\n  }\n}\n\nfunction needsFixing(policy) {\n  var move = [];\n  Object.keys(policy).forEach(function (id) {\n    policy[id].forEach(function (rule) {\n      var keys = Object.keys(rule);\n      keys.shift(); // drop the first\n\n      if (keys === 0) {\n        return;\n      }\n\n      // this means our policy has become corrupted, and we need to move\n      // the additional keys into their own position in the policy\n      keys.forEach(function (key) {\n        move.push({\n          id: id,\n          key: key,\n          rule: rule[key],\n        });\n        delete rule[key];\n      });\n    });\n  });\n\n  return move.length ? move : false;\n}\n\nfunction getFailThreshold(policy) {\n  var threshold = null;\n\n  // pluck the value out, and support all sorts of silly typos\n  [\n    'failThreshold',\n    'fail_threshold',\n    'failthreshold',\n    'threshold',\n    'fail_threshhold',\n  ].some(function (key) {\n    // if we have the value, set it and return it - which will exit loop\n    return threshold = policy[key] || null; // jshint ignore:line\n  });\n\n  if (!threshold) {\n    return null;\n  }\n\n  var valid = ['high', 'medium', 'low'];\n\n  threshold = threshold.toLowerCase().trim();\n\n  if (valid.indexOf(threshold) === -1) {\n    var error = new Error('unknown threshold value \"' + threshold + '\"');\n    error.code = 'POLICY_BAD_THRESHOLD';\n    throw error;\n  }\n\n  return threshold;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/filter/index.js":"module.exports = filter;\n\nvar debug = require('debug')('snyk:policy');\nvar ignore = require('./ignore');\nvar patch = require('./patch');\nvar notes = require('./notes');\n\n// warning: mutates vulns\nfunction filter(vulns, policy, root) {\n  if (!root) {\n    root = process.cwd();\n  }\n\n  if (vulns.ok) {\n    return vulns;\n  }\n\n  var filtered = {\n    ignore: [],\n    patch: [],\n  };\n\n  // strip the ignored modules from the results\n  vulns.vulnerabilities = ignore(\n    policy.ignore,\n    vulns.vulnerabilities,\n    filtered.ignore\n  );\n\n  vulns.vulnerabilities = patch(\n    policy.patch,\n    vulns.vulnerabilities,\n    root,\n    policy.skipVerifyPatch ? true : false,\n    filtered.patch\n  );\n\n  if (policy.suggest) {\n    vulns.vulnerabilities = notes(\n      policy.suggest,\n      vulns.vulnerabilities,\n      root\n    );\n  }\n\n  // if there's no vulns after the ignore process, let's reset the `ok`\n  // state and remove the vulns entirely.\n  if (vulns.vulnerabilities.length === 0) {\n    vulns.ok = true;\n    vulns.vulnerabilities = [];\n  }\n\n  vulns.filtered = filtered;\n\n  debug('> has threshold? %s', policy.failThreshold);\n\n  if (policy.failThreshold && vulns.ok === false) {\n    // check what's left and switch the failure flag if there's anything\n    // under our threshold\n    var levels = {\n      high: 3,\n      medium: 2,\n      low: 1,\n    };\n    var level = levels[policy.failThreshold];\n    vulns.ok = true;\n    vulns.vulnerabilities.some(function (vuln) {\n      if (levels[vuln.severity] >= level) {\n        vulns.ok = false;\n        return true; // breaks\n      }\n    });\n  }\n\n  return vulns;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/filter/ignore.js":"module.exports = filterIgnored;\n\nvar debug = require('debug')('snyk:policy');\nvar matchToRule = require('../match').matchToRule;\n\n// given an ignore ruleset (parsed from the .snyk yaml file) and a array of\n// vulnerabilities, return the vulnerabilities that *are not* ignored\n// see http://git.io/vCHmV for example of what ignore structure looks like\nfunction filterIgnored(ignore, vuln, filtered) {\n  if (!ignore) {\n    return vuln;\n  }\n\n  if (!filtered) {\n    filtered = [];\n  }\n\n  debug('filtering ignored');\n  var now = (new Date()).toJSON();\n\n  return vuln.map(function (vuln) {\n    if (!ignore[vuln.id]) {\n      return vuln;\n    }\n\n    debug('%s has rules', vuln.id);\n\n    // logic: loop through all rules (from `ignore[vuln.id]`), and if *any* dep\n    // paths match our vuln.from dep chain AND the rule hasn't expired, then the\n    // vulnerability is ignored. if none of the rules match, then let we'll\n    // keep it.\n\n    // if rules.find, then ignore vuln\n    var appliedRules = ignore[vuln.id].filter(function (rule) {\n      var path = Object.keys(rule)[0]; // this is a string\n      var expires = rule[path].expires;\n\n      // first check if the path is a match on the rule\n      var pathMatch = matchToRule(vuln, rule);\n\n      if (pathMatch && expires < now) {\n        debug('%s vuln rule has expired (%s)', vuln.id, expires);\n        return false;\n      }\n\n      if (pathMatch) {\n        debug('ignoring based on path match: %s ~= %s', path,\n          vuln.from.slice(1).join(' > '));\n        return true;\n      }\n\n      return false;\n    });\n\n    if (appliedRules.length) {\n      vuln.filtered = {\n        ignored: appliedRules.map(function (rule) {\n          return rule[Object.keys(rule)[0]];\n        }),\n      };\n      filtered.push(vuln);\n    }\n\n    return appliedRules.length ? false : vuln;\n  }).filter(Boolean);\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/filter/patch.js":"module.exports = filterPatched;\n\nvar debug = require('debug')('snyk:policy');\nvar matchToRule = require('../match').matchToRule;\nvar path = require('path');\nvar statSync = require('fs').statSync;\nvar getVulnSource = require('./get-vuln-source');\n\n// cwd is used for testing\nfunction filterPatched(patched, vulns, cwd, skipVerifyPatch, filteredPatches) {\n  if (!patched) {\n    return vulns;\n  }\n\n  if (!filteredPatches) {\n    filteredPatches = [];\n  }\n\n\n  debug('filtering patched');\n  return vulns.map(function (vuln) {\n    if (!patched[vuln.id]) {\n      return vuln;\n    }\n\n    debug('%s has rules', vuln.id);\n\n    // logic: loop through all rules (from `patched[vuln.id]`), and if *any* dep\n    // paths match our vuln.from dep chain AND a flag exists, then the\n    // vulnerability is ignored. if none of the rules match, then let we'll\n    // keep it.\n\n    // if rules.find, then ignore vuln\n    var vulnRules = patched[vuln.id].map(function (rule) {\n\n      // first check if the path is a match on the rule\n      var pathMatch = matchToRule(vuln, rule);\n\n      if (pathMatch) {\n        var path = Object.keys(rule)[0]; // this is a string\n        debug('(patch) ignoring based on path match: %s ~= %s', path,\n          vuln.from.slice(1).join(' > '));\n        return rule;\n      }\n\n      return false;\n    }).filter(Boolean);\n\n    // run through the potential rules to check if there's a patch flag in place\n    var appliedRules = vulnRules.filter(function () {\n      // the target directory where our module name will live\n      if (skipVerifyPatch) {\n        return true;\n      }\n\n      var source = getVulnSource(vuln, cwd, true);\n\n      var id = vuln.id.replace(/:/g, '-');\n      var flag = path.resolve(source, '.snyk-' + id + '.flag');\n      var oldFlag = path.resolve(source, '.snyk-' + vuln.id + '.flag');\n      var res = false;\n      try {\n        res = statSync(flag);\n      } catch (e) {\n        try {\n          res = statSync(oldFlag);\n        } catch (e) {}\n      }\n\n      debug('flag found for %s? %s', vuln.id);\n\n      return !!res;\n    });\n\n    if (appliedRules.length) {\n      vuln.filtered = {\n        patches: appliedRules.map(function (rule) {\n          return rule[Object.keys(rule)[0]];\n        }),\n      };\n      filteredPatches.push(vuln);\n    }\n\n    return appliedRules.length ? false : vuln;\n  }).filter(Boolean);\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/filter/get-vuln-source.js":"// FIXME move to ext module\n\nmodule.exports = getVulnSource;\n\nvar debug = require('debug')('snyk:policy');\nvar resolve = require('snyk-resolve');\nvar path = require('path');\nvar statSync = require('fs').statSync;\nvar moduleToObject = require('snyk-module');\n\nfunction getVulnSource(vuln, cwd, live) {\n  var from = vuln.from.slice(1).map(function (pkg) {\n    return moduleToObject(pkg).name;\n  });\n\n  var viaPath = path.resolve(\n    cwd || process.cwd(),\n    'node_modules',\n    from.join('/node_modules/')\n  );\n\n  var source = vuln.__filename ?\n      path.dirname(vuln.__filename) :\n      viaPath;\n\n  // try to stat the directory, if it throws, it doesn't exist...\n  try {\n    statSync(source);\n  } catch (e) {\n    // ...which means the package is located in a parent path (from an\n    // npm dedupe process), so we remove the module name from the path\n    // and use the `resolve` package to navigate the node_modules up\n    // through parent directories.\n    try {\n      source = resolve.sync(from.slice(-1).pop(), viaPath);\n    } catch (e) {\n      if (live) {\n        throw e;\n      }\n\n      // otherwise this is a dry run so we don't mind that it won't be\n      // able to patch - likely a scenario run, so it's fine that the\n      // patch target won't be found\n    }\n    debug('found better source for package: %s', source);\n  }\n\n  return source;\n}\n\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/filter/notes.js":"module.exports = attachNotes;\n\nvar debug = require('debug')('snyk:policy');\nvar matchToRule = require('../match').matchToRule;\n\nfunction attachNotes(notes, vuln) {\n  if (!notes) {\n    return vuln;\n  }\n  debug('attaching notes');\n  var now = (new Date()).toJSON();\n\n  return vuln.map(function (vuln) {\n    if (!notes[vuln.id]) {\n      return vuln;\n    }\n\n    debug('%s has rules', vuln.id);\n\n    // if rules.some, then add note to the vuln\n    notes[vuln.id].forEach(function (rule) {\n      var path = Object.keys(rule)[0]; // this is a string\n      var expires = rule[path].expires;\n\n      // first check if the path is a match on the rule\n      var pathMatch = matchToRule(vuln, rule);\n\n      if (pathMatch && expires < now) {\n        debug('%s vuln rule has expired (%s)', vuln.id, expires);\n        return false;\n      }\n\n      if (pathMatch) {\n        // strip any control characters in the 3rd party reason file\n        var reason = rule[path].reason.replace('/[\\x00-\\x1F\\x7F-\\x9F]/u', '');\n        debug('adding note based on path match: %s ~= %s', path,\n          vuln.from.slice(1).join(' > '));\n        vuln.note = 'Snyk policy in ' + rule[path].from +\n          ' suggests ignoring this issue, with reason: ' + reason;\n      }\n\n      return false;\n    });\n\n    return vuln;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-policy/lib/add.js":"module.exports = add;\n\nvar debug = require('debug')('snyk:policy');\n\nfunction add(policy, type, options) {\n  if (type !== 'ignore' && type !== 'patch') {\n    throw new Error('policy.add: unknown type \"' + type + '\" to add to');\n  }\n\n  if (!options || !options.id || !options.path) {\n    throw new Error('policy.add: required option props { id, path }');\n  }\n\n  var id = options.id;\n  var path = options.path;\n  var data = Object.keys(options).reduce(function (acc, curr) {\n    if (curr === 'id' || curr === 'path') {\n      return acc;\n    }\n\n    acc[curr] = options[curr];\n    return acc;\n  }, {});\n\n  if (!policy[type][id]) {\n    policy[type][id] = [];\n  }\n\n  /* istanbul ignore if */\n  if (policy[type][id][path]) {\n    debug('policy.add: path already exists', policy[type][id][path]);\n  }\n\n  var rule = {};\n  rule[path] = data;\n\n  policy[type][id].push(rule);\n\n  return policy;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/args.js":"module.exports = args;\n\nvar abbrev = require('abbrev');\nvar alias = abbrev('copy', 'version', 'debug', 'help', 'quiet', 'interactive',\n  'dev');\nalias.d = 'debug'; // always make `-d` debug\nalias.t = 'test';\n\nfunction args(processargv) {\n  // allows us to support flags with true or false only\n  var argv = processargv.slice(2).reduce(function reduce(acc, arg) {\n    if (arg.indexOf('-') === 0) {\n      arg = arg.slice(1);\n\n      if (alias[arg] !== undefined) {\n        acc[alias[arg]] = true;\n      } else if (arg.indexOf('-') === 0) {\n        arg = arg.slice(1);\n        if (arg.indexOf('=') === -1) {\n          acc[arg] = true;\n        } else {\n          var parts = arg.split('=');\n          acc[parts.shift()] = parts.join('=');\n        }\n      } else {\n        acc[arg] = true;\n      }\n    } else {\n      acc._.push(arg);\n    }\n\n    return acc;\n  }, { _: [] });\n\n  // by passing `-d` to the cli, we enable the debugging output, but this must\n  // be as early as possible in the cli logic to capture all the output\n  if (argv.debug) {\n    var enable = 'snyk';\n    if (process.env.DEBUG) {\n      enable += ',' + process.env.DEBUG;\n    }\n    require('debug').enable(enable);\n  }\n\n  var debug = require('debug')('snyk');\n\n  // this is done after the debug activation line above because we want to see\n  // the debug messaging when we use the `-d` flag\n  var cli = require('./commands');\n\n  // the first argument is the command we'll execute, everything else will be\n  // an argument to our command, like `snyk help protect`\n  var command = argv._.shift();\n\n  // alias switcheroo - allows us to have\n  if (cli.aliases[command]) {\n    command = cli.aliases[command];\n  }\n\n  // alias `-v` to `snyk version`\n  if (argv.version) {\n    command = 'version';\n  }\n\n  if (!command || argv.help || command === 'help') {\n    // bit of a song and dance to support `snyk -h` and `snyk help`\n    if (argv.help === true || command === 'help') {\n      argv.help = 'help';\n    }\n    command = 'help';\n\n    if (!argv._.length) {\n      argv._.unshift(argv.help || 'usage');\n    }\n  }\n\n  if (command && command.indexOf('config:') === 0) {\n    // config looks like `config:set x=y` or `config:get x`\n    // so we need to mangle the commands into this format:\n    // snyk.config('set', 'api=x')\n    // snyk.config('get', 'api') // etc\n    var tmp = command.split(':');\n    command = tmp.shift();\n    argv._.unshift(tmp.shift());\n  }\n\n  var method = cli[command];\n\n  if (!method) {\n    // if we failed to find a command, then default to an error\n    if (!method) {\n      method = require('../lib/error');\n      argv._.push(command);\n    }\n  }\n\n  // TODO decide why we can't do this cart blanche...\n  if (command === 'protect' ||\n      command === 'test' ||\n      command === 'modules' ||\n      command === 'scenario' ||\n      command === 'monitor' ||\n      command === 'wizard' ||\n      command === 'ignore') {\n    // copy all the options across to argv._ as an object\n    argv._.push(argv);\n  }\n\n  debug(command, argv);\n\n  return {\n    method: method,\n    command: command,\n    options: argv,\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/copy.js":"module.exports = copy;\n\nvar cp = require('child_process');\nvar program = {\n  darwin: 'pbcopy',\n  win32: 'clip',\n  linux: 'xclip -selection clipboard',\n}[process.platform];\n\nfunction copy(str) {\n  return cp.execSync(program, { input: str });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/index.js":"#!/usr/bin/env node\n\nvar args = require('./args')(process.argv);\nvar debug = require('debug')('snyk');\nvar copy = require('./copy');\n\nvar exitcode = 0;\n\nvar cli = args.method.apply(null, args.options._).then(function (result) {\n  var analytics = require('../lib/analytics');\n  var res = analytics({\n    command: args.command,\n    args: args.options._,\n  });\n  if (result && !args.options.quiet) {\n    if (args.options.copy) {\n      copy(result);\n      console.log('Result copied to clipboard');\n    } else {\n      console.log(result);\n    }\n  }\n  return res;\n}).catch(function (error) {\n  var spinner = require('../lib/spinner');\n  spinner.clearAll();\n  var analytics = require('../lib/analytics');\n  var command = 'bad-command';\n\n  if (error.code === 'VULNS') {\n    // this isn't a bad command, so we won't record it as such\n    command = args.command;\n  } else {\n    analytics.add('error-message', error.message);\n    analytics.add('error', error.stack);\n    analytics.add('error-code', error.code);\n    analytics.add('command', args.command);\n  }\n\n  var res = analytics({\n    command: command,\n    args: args.options._,\n  });\n\n  if (args.options.debug) {\n    console.log(error.stack);\n  } else {\n    var errors = require('../lib/error');\n    if (!args.options.quiet) {\n\n      var result = errors.message(error);\n      if (args.options.copy) {\n        copy(result);\n        console.log('Result copied to clipboard');\n      } else {\n        if ((error.code + '').indexOf('AUTH_') === 0) {\n          var ansiEscapes = require('ansi-escapes');\n          // remove the last few lines\n          var erase = ansiEscapes.eraseLines(4);\n          process.stdout.write(erase);\n        }\n        console.log(result);\n      }\n    }\n  }\n\n  exitcode = 1;\n  return res;\n}).catch(function (e) {\n  console.log('super fail', e.stack);\n}).then(function (res) {\n  if (!process.env.TAP && exitcode) {\n    return process.exit(1);\n  }\n  return res;\n});\n\nif (module.parent) {\n  module.exports = cli;\n} else {\n  debug('checking for cli updates');\n  // finally, check for available update and returns an instance\n  var defaults = require('../dist/lodash-min').defaults;\n  var pkg = require('../package.json');\n\n  // only run if we're not inside an npm.script\n  if (!process.env['npm_config_node_version']) { // jshint ignore:line\n    require('update-notifier')({\n      pkg: defaults(pkg, { version: '0.0.0' }),\n    }).notify();\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/index.js":"var abbrev = require('abbrev');\nvar hotload = require('../../lib/hotload')(__dirname);\nrequire('../../lib/spinner').isRequired = false;\n\n// the aim of this module is to load as little as possible to keep cli boot\n// time as low as possible\n\nvar commands = {\n  auth: hotload('./auth'),\n  config: hotload('./config'),\n  help: hotload('./help'),\n  ignore: hotload('./ignore'),\n  modules: hotload('./modules'),\n  monitor: hotload('./monitor'),\n  policy: hotload('./policy'),\n  protect: hotload('./protect'),\n  scenario: hotload('./scenario'),\n  test: hotload('./test'),\n  'test-unpublished': hotload('./unpublished'),\n  version: hotload('./version'),\n  wizard: hotload('./protect/wizard'),\n};\ncommands.aliases = abbrev(Object.keys(commands));\ncommands.aliases.t = 'test';\nmodule.exports = commands;\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/hotload.js":"module.exports = hotload;\n\nvar path = require('path');\n\n// this will speed up the module load time, only loading the CLI commands\n// as needed by the user, and totally avoiding if the module is being required\n// into a user project\nfunction hotload(dir) {\n  return function (name) {\n    var module = null;\n    return function () {\n      if (module === null) {\n        module = require(path.relative(__dirname, path.resolve(dir, name)));\n      }\n\n      return module.apply(null, arguments);\n    };\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/help.js":"module.exports = help;\n\nvar fs = require('then-fs');\nvar path = require('path');\n\nfunction help(item) {\n  if (!item || item === true || typeof item !== 'string') {\n    item = 'usage';\n  }\n\n  // cleanse the filename to only contain letters\n  // aka: /\\W/g but figured this was eaiser to read\n  item = item.replace(/[^a-z-]/gi, '');\n\n  var filename = path.resolve(__dirname, '..', '..', 'help', item + '.txt');\n  return fs.readFile(filename, 'utf8')\n    .catch(function () {\n      return '\"' + item + '\" help can\\'t be found';\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/capture.js":"module.exports = captureRequires;\n\nvar path = require('path');\nvar modules = [];\nvar snyk = require('..');\n\nfunction captureRequires() {\n  var timer = null;\n  snyk.bus.on('after:module', function (module) {\n    clearTimeout(timer);\n    modules.push(module);\n\n    // full task (rather than microtask)\n    timer = setTimeout(resolve, 100);\n  });\n}\n\nfunction resolve() {\n  // the monitor should capture everything *excluding* snyk modules\n  // and post up to the snyk registry for the user\n  var paths = modules.map(function (module) {\n    return module.id;\n  });\n\n  // work out the root directory of the project...\n  var candidate = paths.reduce(function (acc, curr) {\n    if (curr.indexOf('node_modules') === -1) {\n      return acc;\n    }\n\n    var path = curr\n      .split('node_modules')\n      .slice(0, -1)\n      .join('node_modules') + 'node_modules';\n\n    if (acc.indexOf(path) === -1) {\n      acc.push(path);\n    }\n\n    return acc;\n  }, []).sort().shift();\n\n  // then collect all the package deps and post a monitor\n  var cwd = path.resolve(candidate, '..');\n  snyk.modules(cwd).then(snyk.monitor.bind(null, cwd, {\n    method: 'require',\n  }));\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/display-policy.js":"module.exports = display;\n\nvar chalk = require('chalk');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar demunge = require('snyk-policy').demunge;\nvar config = require('./config');\n\nfunction display(policy) {\n  return new Promise(function (resolve) {\n    var p = demunge(policy, config.ROOT);\n\n    var res = chalk.bold('Current Snyk policy, read from ' + policy.__filename +\n      ' file') + '\\n';\n    res += 'Modified: ' + policy.__modified + '\\n';\n    res += 'Created:  ' + policy.__created + '\\n';\n\n    res += p.patch.map(displayRule('Patch vulnerability')).join('\\n');\n    if (p.patch.length && p.ignore.length) {\n      res += '\\n\\n------------------------\\n';\n    }\n    res += p.ignore.map(displayRule('Ignore')).join('\\n');\n\n    resolve(res);\n  });\n}\n\nfunction displayRule(title) {\n  return function (rule, i) {\n    i += 1;\n    return chalk.bold('\\n#' + i + ' ' + title + ' ' + rule.url) +\n      ' in the following paths:\\n' +\n      (rule.paths.map(function (p) {\n        return p.path +\n               (p.reason ? '\\nReason: ' + p.reason +\n               '\\nExpires: ' + p.expires.toUTCString() + '\\n': '')  + '\\n';\n      }).join('').replace(/\\s*$/, ''));\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/error.js":"var Promise = require('es6-promise').Promise; // jshint ignore:line\nvar config = require('../lib/config');\nvar chalk = require('chalk');\n\nvar errors = {\n  connect: 'Check your network connection, failed to connect to Snyk API',\n  endpoint: 'The Snyk API is not available on ' + config.API,\n  auth: 'Unauthorized: please ensure you are logged in using `snyk auth`',\n  dotfile: 'Try running `snyk wizard` to define a Snyk protect policy',\n  authfail: 'Authentication failed. Please check the API token on ' +\n    config.ROOT,\n  oldsnyk: 'You have an alpha format Snyk policy file in this directory. ' +\n    'Please remove it, and re-create using `snyk wizard`',\n  notfound: 'The package could not be found or does not exist',\n  patchfail: 'The patch against %s failed.',\n  updatefail: 'Encountered errors while running `npm update`.\\nRun ' +\n    '`npm update` when the wizard completes to ensure updates have been ' +\n    'applied.',\n  updatepackage: 'Upgrade this package to \"%s\", then run the wizard again.',\n  nodeModules: 'This directory looks like a node project, but is missing the ' +\n    'contents of the node_modules directory.\\nPlease run `npm install` and ' +\n    're-run your snyk command.',\n  tryDevDeps: 'Snyk only tests production dependencies by default (which ' +\n    'this project had none). Try re-running with the `--dev` flag.',\n  noAuthInCI: 'Github auth cannot be used whilst inside CI. You must include ' +\n    'your API token as an environment value: `API=12345678`',\n  noApiToken: '%s requires an authenticated account. Please run `snyk auth` ' +\n    'and try again.',\n  timeout: 'The request has timed out on the server side.\\nPlease re-run ' +\n    'this command with the `-d` flag and send the output to support@snyk.io.',\n  policyFile: 'Bad policy file, please use --path=PATH to specify a ' +\n    'directory with a .snyk file',\n  idRequired: 'id is a required field for `snyk ignore`',\n};\n\n// a key/value pair of error.code (or error.message) as the key, and our nice\n// strings as the value.\nvar codes = {\n  ECONNREFUSED: errors.connect,\n  ENOTFOUND: errors.connect,\n  NOT_FOUND: errors.notfound,\n  404: errors.notfound,\n  411: errors.endpoint, // try to post to a weird endpoint\n  403: errors.endpoint,\n  401: errors.auth,\n  Unauthorized: errors.auth,\n  MISSING_DOTFILE: errors.dotfile,\n  MISSING_NODE_MODULES: errors.nodeModules,\n  OLD_DOTFILE_FORMAT: errors.oldsnyk,\n  FAIL_PATCH: errors.patchfail,\n  FAIL_UPDATE: errors.updatefail,\n  NOT_FOUND_HAS_DEV_DEPS: errors.tryDevDeps,\n  NO_API_TOKEN: errors.noApiToken,\n  502: errors.timeout,\n  504: errors.timeout,\n};\n\nmodule.exports = function error(command) {\n  var e = new Error('Unknown command \"' + command + '\"');\n  e.code = 'UNKNOWN_COMMAND';\n  return Promise.reject(e);\n};\n\nmodule.exports.message = function (error) {\n  var message = error; // defaults to a string (which is super unlikely)\n  if (error instanceof Error) {\n    if (error.code === 'VULNS') {\n      return error.message;\n    }\n\n    // try to lookup the error string based either on the error code OR\n    // the actual error.message (which can be \"Unauthorized\" for instance),\n    // otherwise send the error message back\n    message = codes[error.code || error.message] ||\n              errors[error.code || error.message];\n    if (message) {\n      message = message.replace(/(%s)/g, error.message).trim();\n      message = chalk.bold.red(message);\n    } else if (error.code) { // means it's a code error\n      message = 'An unknown error occurred. Please include the trace below ' +\n                'when reporting to Snyk:\\n\\n' + error.stack;\n    } else { // should be one of ours\n      message = error.message;\n    }\n  }\n\n  return message;\n};\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/hook.js":"module.exports = function () {\n  hookExtensions(['.js']);\n};\n\nvar forEach = require('../dist/lodash-min').forEach;\nvar fs = require('fs');\nvar oldHandlers = {};\nvar snyk = require('..');\n\n// source: https://github.com/joyent/node/blob/master/lib/module.js#L466\nfunction stripBOM(content) {\n  // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nfunction loader(module, filename) {\n  snyk.bus.emit('before:module', filename);\n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(stripBOM(content), filename);\n  snyk.bus.emit('after:module', module);\n}\n\nfunction registerExtension(ext) {\n  var old = oldHandlers[ext] || oldHandlers['.js'] || require.extensions['.js'];\n\n  require.extensions[ext] = function (m, filename) {\n    if (snyk.isolate.okay(filename)) {\n      loader(m, filename, old);\n    }\n  };\n}\n\n\nfunction hookExtensions(_exts) {\n  forEach(oldHandlers, function (old, ext) {\n    if (old === undefined) {\n      delete require.extensions[ext];\n    } else {\n      require.extensions[ext] = old;\n    }\n  });\n\n  oldHandlers = {};\n\n  forEach(_exts, function (ext) {\n    oldHandlers[ext] = require.extensions[ext];\n    registerExtension(ext);\n  });\n}\n// TODO: unhook\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/isolate.js":"module.exports = isolate;\nmodule.exports.okay = okay;\n\nvar snyk = require('..');\nvar semver = require('semver');\nvar fs = require('fs');\n\nvar modules = {};\nvar potentialBlacklist = {};\n\nfunction isolate(options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (Array.isArray(options.isolate)) {\n    potentialBlacklist = options.isolate.map(function (pkg) {\n      var i = pkg.lastIndexOf('@');\n      return {\n        name: pkg.slice(0, i),\n        version: pkg.slice(i + 1),\n      };\n    }).reduce(function (acc, curr) {\n      acc[curr.name] = curr;\n      return acc;\n    }, {});\n  }\n\n  snyk.bus.on('after:module', function (module) {\n    instrumentProps(module.id, module.id, module.exports);\n  });\n}\n\n\n\nfunction instrumentProps(id, key, obj) {\n  // only apply once\n  if (obj.__snyked) {\n    return obj;\n  }\n\n  obj.__snyked = true;\n  var type = typeof obj;\n  var original = obj;\n\n  if (type === 'function') {\n    obj = function instrumented() {\n      console.log('NOTIFY: %s@%s', key || id, id);\n      // snyk.notify(key, id);\n      original.apply(this, arguments);\n    };\n  }\n\n  if (type === 'object' || type === 'function') {\n    Object.keys(original).forEach(function (key) {\n      var prop = original[key];\n      if (key === '__snyked') {\n        return;\n      }\n      obj[key] = instrumentProps(id, key, prop);\n    });\n  }\n\n  console.log('instrumented %s@%s', key, id.split('/').pop());\n\n  return obj;\n}\n\nfunction okay(filename) {\n  return !checkIsolation(filename);\n}\n\nfunction checkIsolation(filename) {\n  var parts = filename.split('node_modules/');\n  var module = parts.slice(-1)[0].split('/')[0];\n  if (!modules[module] && module) {\n    modules[module] = true;\n\n    var check = potentialBlacklist[module];\n\n    if (check) {\n      var pkgFilename = filename.split(module)[0];\n      var pkg = fs.readFileSync(pkgFilename + module + '/package.json');\n      var version;\n      try {\n        version = JSON.parse(pkg).version;\n      } catch (e) {}\n      if (version) {\n        if (semver.satisfies(version, check.version)) {\n          throw new Error('Snyk: Isolated module \"' + check.name +\n            '@' + check.version + '\" was not allowed to load');\n        }\n      }\n    }\n\n  }\n\n  // lookup the version\n\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/npm.js":"module.exports = npm;\n\nvar debug = require('debug')('snyk');\nvar exec = require('child_process').exec;\n\nfunction npm(method, packages, live, cwd, flags) {\n  flags = flags || [];\n  if (!packages) {\n    packages = [];\n  }\n\n  if (!Array.isArray(packages)) {\n    packages = [packages];\n  }\n\n  // only if we have packages, then always save, otherwise the command might\n  // be something like `npm shrinkwrap'\n  if (packages.length && !flags.length) {\n    flags.push('--save');\n  }\n\n  method += ' ' + flags.join(' ');\n\n  return new Promise(function (resolve, reject) {\n    var cmd = 'npm ' + method + ' ' + packages.join(' ');\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n    debug('%s$ %s', cwd, cmd);\n\n    if (!live) {\n      debug('[skipping - dry run]');\n      return resolve();\n    }\n\n    exec(cmd, {\n      cwd: cwd,\n    }, function (error, stdout, stderr) {\n      if (error) {\n        return reject(error);\n      }\n\n      if (stderr.indexOf('ERR!') !== -1) {\n        console.error(stderr.trim());\n        var e = new Error('npm update errors');\n        e.code = 'FAIL_UPDATE';\n        return reject(e);\n      }\n\n      debug('npm %s complete', method);\n\n      resolve();\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/sub-process.js":"var Promise = require('es6-promise').Promise;\nvar childProcess = require('child_process');\n\nmodule.exports.execute = function (command, args, options) {\n  var spawnOptions = { shell: true };\n  if (options && options.cwd) {\n    spawnOptions.cwd = options.cwd;\n  }\n\n  return new Promise(function (resolve, reject) {\n    var stdout = '';\n    var stderr = '';\n\n    var proc = childProcess.spawn(command, args, spawnOptions);\n    proc.stdout.on('data', function (data) { stdout = stdout + data; });\n    proc.stderr.on('data', function (data) { stderr = stderr + data; });\n\n    proc.on('close', function (code) {\n      if (code !== 0) {\n        return reject(stdout || stderr);\n      }\n      resolve({ stdout: stdout, stderr: stderr });\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/yarn.js":"module.exports = yarn;\n\nvar debug = require('debug')('snyk');\nvar exec = require('child_process').exec;\n\nfunction yarn(method, packages, live, cwd, flags) {\n  flags = flags || [];\n  if (!packages) {\n    packages = [];\n  }\n\n  if (!Array.isArray(packages)) {\n    packages = [packages];\n  }\n\n  method += ' ' + flags.join(' ');\n\n  return new Promise(function (resolve, reject) {\n    var cmd = 'yarn ' + method + ' ' + packages.join(' ');\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n    debug('%s$ %s', cwd, cmd);\n\n    if (!live) {\n      debug('[skipping - dry run]');\n      return resolve();\n    }\n\n    exec(cmd, {\n      cwd: cwd,\n    }, function (error, stdout, stderr) {\n      if (error) {\n        return reject(error);\n      }\n\n      if (stderr.indexOf('ERR!') !== -1) {\n        console.error(stderr.trim());\n        var e = new Error('yarn update errors');\n        e.code = 'FAIL_UPDATE';\n        return reject(e);\n      }\n\n      debug('yarn %s complete', method);\n\n      resolve();\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/auth.js":"module.exports = auth;\nmodule.exports.isAuthed = isAuthed;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar debug = require('debug')('snyk');\nvar open = require('open');\nvar snyk = require('../../lib/');\nvar config = require('../../lib/config');\nvar isCI = require('../../lib/is-ci');\nvar request = require('../../lib/request');\nvar url = require('url');\nvar uuid = require('uuid');\nvar spinner = require('../../lib/spinner');\nvar apiUrl = url.parse(config.API);\nvar authUrl = apiUrl.protocol + '//' + apiUrl.host;\nvar attemptsLeft = 0;\n\nfunction resetAttempts() {\n  attemptsLeft = 30;\n}\n\nfunction githubAuth(via) {\n  var token = uuid.v4(); // generate a random key\n  var redirects = {\n    wizard: '/authenticated',\n  };\n\n  var url = authUrl + '/login?token=' + token;\n\n  // validate that via comes from our code, and not from user & CLI\n  // currently only support `wizard` but we'll add more over time.\n  if (redirects[via]) {\n    url += '&redirectUri=' + new Buffer(redirects[via]).toString('base64');\n  }\n\n  var msg =\n    '\\nNow redirecting you to our github auth page, go ahead and log in,\\n' +\n    'and once the auth is complete, return to this prompt and you\\'ll\\n' +\n    'be ready to start using snyk.\\n\\nIf you can\\'t wait use this url:\\n' +\n    url + '\\n';\n\n  // suppress this message in CI\n  if (!isCI) {\n    console.log(msg);\n  } else {\n    var error = new Error('noAuthInCI');\n    error.code = 'AUTH_IN_CI';\n    return Promise.reject(error);\n  }\n\n  var lbl = 'Waiting...';\n\n  return spinner(lbl).then(function () {\n    setTimeout(function () {\n      open(url);\n    }, 2000);\n    // start checking the token immediately in case they've already\n    // opened the url manually\n    return testAuthComplete(token).then(spinner.clear(lbl));\n  });\n}\n\nfunction testAuthComplete(token) {\n  var payload = {\n    body: {\n      token: token,\n    },\n    url: config.API + '/verify/callback',\n    json: true,\n    method: 'post',\n  };\n\n  return new Promise(function (resolve, reject) {\n    debug(payload);\n    request(payload, function (error, res, body) {\n      debug(error, (res || {}).statusCode, body);\n      if (error) {\n        return reject(error);\n      }\n\n\n      if (res.statusCode !== 200) {\n        var e = new Error(body.message);\n        e.code = res.statusCode;\n        return reject(e);\n      }\n\n      // we have success\n      if (body.api) {\n        return resolve({\n          res: res,\n          body: body,\n        });\n      }\n\n      // we need to wait and poll again in a moment\n      setTimeout(function () {\n        attemptsLeft--;\n        if (attemptsLeft > 0) {\n          return resolve(testAuthComplete(token));\n        }\n\n        var error = new Error('Sorry, but your authentication token has now' +\n          ' expired.\\nPlease try to authenticate again.');\n        error.code = 'AUTH_TIMEOUT';\n        reject(error);\n      }, 1000);\n    });\n  });\n}\n\nfunction isAuthed() {\n  var token = snyk.config.get('api');\n  return verifyAPI(token).then(function (res) {\n    return res.body.ok;\n  });\n}\n\nfunction verifyAPI(api) {\n  var payload = {\n    body: {\n      api: api,\n    },\n    method: 'POST',\n    url: config.API + '/verify/token',\n    json: true,\n  };\n\n  return new Promise(function (resolve, reject) {\n    request(payload, function (error, res, body) {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve({\n        res: res,\n        body: body,\n      });\n    });\n  });\n}\n\nfunction auth(api, via) {\n  var promise;\n  resetAttempts();\n  if (api) {\n    // user is manually setting the API token on the CLI - let's trust them\n    promise = verifyAPI(api);\n  } else {\n    promise = githubAuth(via);\n  }\n\n  return promise.then(function (data) {\n    var res = data.res;\n    var body = res.body;\n    debug(body);\n\n    if (res.statusCode === 200 || res.statusCode === 201) {\n      snyk.config.set('api', body.api);\n      return '\\nYour account has been authenticated. Snyk is now ready to ' +\n        'be used.\\n';\n    }\n\n    if (body.message) {\n      var error = new Error(body.message);\n      error.code = res.statusCode;\n      throw error;\n    }\n\n    throw new Error('authfail');\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/ignore.js":"module.exports = ignore;\n\nvar debug = require('debug')('snyk');\nvar policy = require('snyk-policy');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\n\nfunction ignore(options) {\n  debug('snyk ignore called with options: %O', options);\n  if (!options.id) {\n    return Promise.reject(Error('idRequired'));\n  }\n  options.expiry = new Date(options.expiry);\n  if (options.expiry.getTime() !== options.expiry.getTime()) {\n    debug('No/invalid expiry given, using the default 30 days');\n    options.expiry = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);\n  }\n  if (!options.reason) {\n    options.reason = 'None Given';\n  }\n  if (!options.path) {\n    debug('using cwd() as path');\n    options.path = process.cwd();\n  }\n\n  debug('changing policy: ignore \"%s\", for all paths, reason: \"%s\", until: %o',\n        options.id, options.reason, options.expiry);\n  return policy.load(options.path)\n  .catch(function (error) {\n    if (error.code === 'ENOENT') {    // file does not exist - create it\n      return policy.create();\n    }\n    throw Error('policyFile');\n  })\n  .then(function ignoreIssue(pol) {\n    pol.ignore[options.id] = [\n      {\n        '*':\n        {\n          reason: options.reason,\n          expires: options.expiry,\n        },\n      },\n    ];\n    policy.save(pol, options.path);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/modules.js":"var snyk = require('../../lib');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\n\nmodule.exports = function (path, options) {\n  if (!options) {\n    options = {};\n  }\n  return snyk.modules(path || process.cwd()).then(function (modules) {\n\n    var parent = '';\n    if (modules.parent) {\n      parent = modules.parent.full;\n    }\n\n    if (options.json) {\n      return JSON.stringify(modules, '', 2);\n    }\n\n    return parent + Object.keys(modules.dependencies).map(function (key) {\n      return modules.dependencies[key].full;\n    }).join('\\n');\n  });\n};","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/policy.js":"module.exports = displayPolicy;\n\nvar policy = require('snyk-policy');\nvar display = require('../../lib/display-policy');\n\nfunction displayPolicy(path) {\n  return policy.load(path || process.cwd())\n    .then(display)\n    .catch(function (e) {\n      if (e.code === 'ENOENT') {\n        e.code = 'MISSING_DOTFILE';\n      }\n      throw e;\n    });\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/scenario.js":"module.exports = scenario;\nmodule.exports.loadScenario = loadScenario;\n\nvar debug = require('debug')('snyk');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar fs = require('then-fs');\nvar semver = require('semver');\nvar _ = require('../../dist/lodash-min');\nvar snyk = require('../../lib');\nvar auth = require('./auth');\nvar wizard = require('./protect/wizard');\n\nfunction scenario(casefile, options) {\n  var cache = {\n    isAuthed: auth.isAuthed,\n    test: snyk.test,\n  };\n  auth.isAuthed = function () {\n    return Promise.resolve(true);\n  };\n  return loadScenario(casefile).then(function (data) {\n    snyk.test = scenarioTest(data);\n    options['dry-run'] = true;\n    console.log(data.title || 'Unknown case');\n    debug(JSON.stringify(data, '', 2));\n    // process.exit(1);\n    return wizard(options);\n  }).then(function (res) {\n    snyk.test = cache.test;\n    auth.isAuthed = cache.isAuthed;\n    return res;\n  });\n}\n\nfunction loadScenario(casefile) {\n  if (casefile.indexOf('.json') === -1) {\n    return fs.readFile(casefile, 'utf8').then(parseScenario);\n  }\n\n  return fs.readFile(casefile, 'utf8').then(JSON.parse);\n}\n\nfunction scenarioTest(data) {\n  return function () {\n    return new Promise(function (resolve) {\n      resolve({\n        ok: false,\n        vulnerabilities: data.vulnerabilities.slice(0),\n      });\n    });\n  };\n}\n\nfunction parseScenario(source) {\n  var pkg = {};\n  var data = {};\n  var vulnerabilities = [];\n  var title = /^title:\\s+(.*)$/im;\n  var vuln = /([A-Za-z]\\-\\d+) has.*vuln(?:.*in ([A-Za-z]\\-\\d+))?/mgi;\n  var vulnIds = /([Vv]\\d+)/mgi;\n  // jscs:disable\n  var uses = /([A-Za-z]\\-\\d+|App|app) uses ([A-Za-z]\\-\\d+)(?: and ([A-Za-z]\\-\\d+))*/mgi;\n  // jscs:enable\n  var module = /([A-Za-z]\\-\\d+|App)/gi;\n  var patches = /([Pp]\\d+) fixes (?:.*([Vv]\\d+)+.*in (\\w+))?/mgi;\n  var m;\n\n  pkg.name = 'app';\n  pkg.version = '0.0.0';\n  pkg.full = pkg.name + '@' + pkg.version;\n  pkg.dependencies = {};\n  pkg.path = [pkg.full];\n\n  var packages = {};\n  var k;\n  var p;\n  var i;\n  var path;\n\n  var lines = source.trim().split('\\n').map(trim);\n  for (i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    debug('>>> %s', line);\n\n    // reset all the indicies of the regexp\n    uses.lastIndex = 0;\n    title.lastIndex = 0;\n    vulnIds.lastIndex = 0;\n    module.lastIndex = 0;\n    patches.lastIndex = 0;\n\n    if ((m = title.exec(line)) !== null) {\n      data.title = m[0];\n      continue;\n    }\n\n    // create the relationships\n    if (line.indexOf(' uses ') !== -1) {\n      if ((m = uses.exec(line)) !== null) {\n        if (m[1] === 'App') {\n          debug('App uses...', line);\n          m.slice(2).filter(Boolean).map(function (module) {\n            var p = module.split('-');\n            p[1] = cleanVersion(p[1]);\n            pkg.dependencies[p[0]] = {\n              name: p[0],\n              version: p[1],\n              full: p.join('@'),\n              path: [],\n              dependencies: {},\n            };\n          }); // jshint ignore:line\n          m.shift();\n        }\n\n        p = m[1].split('-');\n        p[1] = cleanVersion(p[1]);\n        var full = p.join('@');\n        if (!packages[full]) {\n          packages[full] = {\n            dependencies: {},\n          };\n        }\n        debug('packages', packages, full);\n\n        m.slice(2).filter(Boolean).map(function (module) {\n          var p = module.split('-');\n          p[1] = cleanVersion(p[1]);\n          debug('package module: %s', module, p.join('@'));\n          packages[full].dependencies[p[0]] = {\n            name: p[0],\n            version: p[1],\n            full: p.join('@'),\n            path: [],\n            dependencies: {},\n          };\n        }); // jshint ignore:line\n      }\n\n      continue;\n    }\n\n    if (line.indexOf(' fixes ') !== -1) {\n      debug('found fixes...');\n\n      var vulns = line.match(vulnIds) || [, 'V1'];\n      debug('vulns found? ', vulns);\n      if ((m = patches.exec(line)) !== null) {\n        for (k = 0; k < vulns.length; k++) {\n          vulnerabilities.forEach(function (vuln) {\n            if (vuln.id === vulns[k]) {\n              if (!vuln.patches) {\n                vuln.patches = [];\n              }\n\n              vuln.patches.push({\n                urls: ['https://example.com/patches/' + m[1]],\n                version: '*',\n                id: 'patch:' + m[1],\n                modificationTime: patchDate(m.slice(-1).pop()),\n              });\n            }\n          }); // jshint ignore:line\n        }\n\n      }\n\n      continue;\n    }\n\n    if (line.indexOf(' has ') !== -1) {\n      debug('vuln found');\n      vuln.lastIndex = 0;\n      if ((m = vuln.exec(line)) !== null) {\n        var vulnIn = (m[1]).split('-');\n        vulnIn[1] = cleanVersion(vulnIn[1]);\n        var fixedIn = (m[2] || '-<0.0.0').split('-'); // there is no fix\n        fixedIn[1] = cleanVersion(fixedIn[1]);\n\n        if (!packages[fixedIn.join('@')]) {\n          packages[fixedIn.join('@')] = {\n            dependencies: {},\n          };\n        }\n\n        m = line.match(vulnIds);\n        if (m === null) {\n          m = ['V1'];\n        }\n        debug('vulnIds', m, line);\n\n        for (k = 0; k < m.length; k++) {\n          var v = m[k];\n\n          // first check if the vuln exists\n          var match = vulnerabilities.filter(function (vuln) {\n            return vuln.id === v;\n          }); // jshint ignore:line\n\n          if (match.length) {\n            match[0].semver = {\n              vulnerable: vulnIn[1],\n              patched: fixedIn[1],\n            };\n            match[0].from = [ pkg.name + '@' + pkg.version, vulnIn.join('@') ];\n            path = !fixedIn[0] ? false : fixedIn.join('@');\n            match[0].upgradePath = [ false, path ];\n            continue;\n          }\n\n          var vulnerability = {\n            moduleName: vulnIn[0],\n            id: v,\n            name: vulnIn[0],\n            version: vulnIn[1],\n            below: vulnIn[1],\n            semver: {\n              vulnerable: vulnIn[1],\n              patched: fixedIn[1],\n            },\n            severity: 'high',\n            info: ['https://example.com/vuln/' + v],\n          };\n\n          var fullfrom = pkg.name + '@' + pkg.version;\n          vulnerability.from = [ fullfrom, vulnIn.join('@') ];\n          path = !fixedIn[0] ? false : fixedIn.join('@');\n          vulnerability.upgradePath = [ false, path ];\n\n          vulnerabilities.push(vulnerability);\n        }\n        continue;\n      }\n    }\n  }\n\n  var deps = Object.keys(pkg.dependencies);\n  if (deps.length === 0) {\n    pkg.dependencies = false;\n  } else {\n    // clean up (and join) dependencies\n    cleanDepTree(deps, pkg, packages);\n  }\n\n  vulnerabilities = vulnerabilities.filter(function (vuln) {\n    // console.log(vuln);\n    debug('checking new vuln: %s', vuln.id);\n    var p;\n    var match = matchDep(vuln.name + '@' + vuln.version, pkg.dependencies);\n    if (match) {\n      vuln.from = match.path.slice(0);\n      vuln.upgradePath = [];\n      var name = vuln.name;\n      var dirty = false;\n      var target = vuln.name + '@' + vuln.semver.patched;\n\n      var packagesFull = Object.keys(packages);\n      for (var i = 0; i < packagesFull.length; i++) {\n        p = packagesFull[i];\n        debug('checking for deep %s ~ %s', p, name);\n\n        if (packages[p].dependencies[name]) {\n          debug('found matching package %s', name);\n          var v = target.split('@').pop();\n          debug('semver.satisfies(%s, %s) === %s',\n            packages[p].dependencies[name].version,\n            v,\n            semver.satisfies(packages[p].dependencies[name].version, v));\n\n          if (semver.satisfies(packages[p].dependencies[name].version, v)) {\n            debug('target found: %s', target);\n            vuln.upgradePath.unshift(target);\n            target = p;\n            dirty = true;\n            name = p.split('@')[0];\n            i = 0;\n            continue;\n          }\n        }\n      }\n\n      if (dirty === false) {\n        for (i = 0; i < packagesFull.length; i++) {\n          p = packagesFull[i];\n\n          debug('checking shallow');\n\n          if (p === target && dirty === false) {\n            debug('target direct found: %s', target);\n            vuln.upgradePath.unshift(target);\n            name = p.split('@')[0];\n            i = 0;\n\n            break;\n          }\n        }\n      }\n\n      if (dirty) {\n        vuln.upgradePath.unshift(target);\n      }\n\n      // now match the lengths\n      var length = vuln.from.length - vuln.upgradePath.length;\n      for (i = 0; i < length; i++) {\n        vuln.upgradePath.unshift(false);\n      }\n\n      return true;\n    }\n\n    debug('no match for vuln');\n  });\n\n  data.pkg = pkg;\n  data.packages = packages;\n  data.vulnerabilities = vulnerabilities;\n\n  return data;\n}\n\nfunction cleanDepTree(deps, pkg, packages) {\n  deps.forEach(function (curr) {\n    var full = pkg.dependencies[curr].full;\n    debug('push on %s with %s', pkg.dependencies[curr].path, pkg.full);\n    pkg.dependencies[curr].path = pkg.path.concat(pkg.dependencies[curr].path);\n    pkg.dependencies[curr].path.push(pkg.dependencies[curr].full);\n    if (packages[full]) {\n      pkg.dependencies[curr].dependencies =\n        _.cloneDeep(packages[full].dependencies);\n      cleanDepTree(\n        Object.keys(pkg.dependencies[curr].dependencies),\n        pkg.dependencies[curr],\n        packages\n      );\n    } else {\n      pkg.dependencies[curr].dependencies = false;\n    }\n  });\n}\n\nfunction trim(s) {\n  return s.trim();\n}\n\nfunction cleanVersion(s) {\n  if (!s) {\n    s = '0';\n  }\n  var version = s.split('.');\n  if (version.length === 1) {\n    return s + '.0.0';\n  }\n\n  if (version.length === 2) {\n    return s + '.0';\n  }\n\n  return s;\n}\n\nfunction matchDep(module, deps) {\n  var keys = Object.keys(deps);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (deps[key].full === module) {\n      return deps[key];\n    }\n\n    if (deps[key].dependencies) {\n      return matchDep(module, deps[key].dependencies);\n    }\n  }\n\n  return false;\n}\n\nfunction patchDate(s) {\n  s = (s || '').toLowerCase();\n  var d = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep',\n    'oct', 'nov', 'dec', ].map(function (d, i) {\n    return s.indexOf(d) === 0 ? i : false;\n  }).filter(Boolean);\n  var date = new Date();\n\n  if (d.length) {\n    date.setMonth(d[0]);\n  }\n  return date.toJSON();\n}\n\n/*\nTitle: Direct upgrade\nA-1 has vuln V1, fixed in A-2\nApp uses A-1\n\n\n\n{\n  \"name\": \"qs-package\",\n  \"version\": \"1.0.0\",\n  \"license\": \"ISC\",\n  \"depType\": \"extraneous\",\n  \"hasDevDependencies\": true,\n  \"full\": \"qs-package@1.0.0\",\n  \"dependencies\": {\n    \"qs\": {\n      \"name\": \"qs\",\n      \"version\": \"0.6.6\",\n      \"full\": \"qs@0.6.6\",\n      \"valid\": true,\n      \"devDependencies\": {\n        \"mocha\": \"*\",\n        \"expect.js\": \"*\"\n      },\n      \"depType\": \"prod\",\n      \"license\": \"none\",\n      \"dep\": \"^0.6.6\",\n      \"dependencies\": false\n    }\n  }\n}\n */\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/protect/wizard.js":"module.exports = wizard;\n// used for testing\nmodule.exports.processAnswers = processAnswers;\nmodule.exports.inquire = inquire;\nmodule.exports.interactive = interactive;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\n\nvar debug = require('debug')('snyk');\nvar path = require('path');\nvar inquirer = require('inquirer');\nvar fs = require('then-fs');\nvar tryRequire = require('snyk-try-require');\nvar chalk = require('chalk');\nvar url = require('url');\nvar _ = require('../../../dist/lodash-min');\nvar exec = require('child_process').exec;\nvar undefsafe = require('undefsafe');\nvar auth = require('../auth');\nvar getVersion = require('../version');\nvar allPrompts = require('./prompts');\nvar answersToTasks = require('./tasks');\nvar snyk = require('../../../lib/');\nvar isCI = require('../../../lib/is-ci');\nvar protect = require('../../../lib/protect');\nvar config = require('../../../lib/config');\nvar spinner = require('../../../lib/spinner');\nvar analytics = require('../../../lib/analytics');\nvar npm = require('../../../lib/npm');\nvar cwd = process.cwd();\nvar detectPackageManager = require('../../../lib/detect').detectPackageManager;\n\nfunction wizard(options) {\n  if (!options) {\n    options = {};\n  }\n  if (config.org) {\n    options.org = config.org;\n  }\n  return processPackageManager(options)\n  .then(processWizardFlow)\n  .catch(function (error) {\n    return Promise.reject(error);\n  });\n}\n\nfunction processPackageManager(options) {\n  var packageManager = detectPackageManager(cwd, options);\n  if (packageManager === 'rubygems') {\n    return Promise.reject(\n      'Snyk wizard for RubyGems projects is not currently supported');\n  }\n  if (packageManager === 'maven') {\n    return Promise.reject(\n      'Snyk wizard for Maven projects is not currently supported');\n  }\n  if (packageManager === 'yarn') {\n    var prompt = {\n      name: 'choose-yarn',\n      message: 'A yarn.lock file was detected.\\n' +\n        '  Should the wizard use Yarn [Y] or npm [n] when applying updates?',\n      type: 'confirm',\n      default: true,\n    };\n    return inquire(prompt, {})\n    .then(function (answer) {\n      if (answer['choose-yarn']) {\n        options.packageManager = packageManager;\n        return Promise.resolve(options);\n      }\n      options.packageManager = 'npm';\n      return Promise.resolve(options);\n    });\n  }\n  options.packageManager = packageManager;\n  return Promise.resolve(options);\n}\n\nfunction processWizardFlow(options) {\n  spinner.sticky();\n\n  if (options['dry-run']) {\n    debug('*** dry run ****');\n  } else {\n    debug('~~~~ LIVE RUN ~~~~');\n  }\n\n  return snyk.policy.load(options).catch(function (error) {\n    // if we land in the catch, but we're in interactive mode, then it means\n    // the file hasn't been created yet, and that's fine, so we'll resolve\n    // with an empty object\n    if (error.code === 'ENOENT') {\n      options.newPolicy = true;\n      return snyk.policy.create();\n    }\n\n    throw error;\n  }).then(function (policy) {\n    return auth.isAuthed().then(function (authed) {\n      analytics.add('inline-auth', !authed);\n      if (!authed) {\n        return auth(null, 'wizard');\n      }\n    }).then(function () {\n      var intro = __dirname + '/../../../help/wizard-intro.txt';\n      return fs.readFile(intro, 'utf8').then(function (str) {\n        if (!isCI) {\n          console.log(str);\n        }\n      }).then(function () {\n        return new Promise(function (resolve) {\n          if (options.newPolicy) {\n            return resolve(); // don't prompt to start over\n          }\n          inquirer.prompt(allPrompts.startOver()).then(function (answers) {\n            analytics.add('start-over', answers['misc-start-over']);\n            if (answers['misc-start-over']) {\n              options['ignore-policy'] = true;\n            }\n            resolve();\n          });\n        });\n      }).then(function () {\n        return snyk.test(cwd, options).then(function (res) {\n          var packageFile = path.resolve(cwd, 'package.json');\n          var licenseIssues = res.vulnerabilities.filter(function (issue) {\n            return issue.type === 'license';\n          });\n          if (licenseIssues) {\n            console.log('\\nLicense issues are not supported by the wizard, ' +\n                        'use `snyk ignore`\\n');\n          }\n          res.vulnerabilities = res.vulnerabilities.filter(function (vuln) {\n            return vuln.type !== 'license';\n          });\n          if (!res.ok) {\n            var vulns = res.vulnerabilities;\n            var paths = vulns.length === 1 ? 'path' : 'paths';\n            var ies = vulns.length === 1 ? 'y' : 'ies';\n            var uniqueCount = _.uniq(vulns.map(function (vuln) {\n              return vuln.id;\n            })).length;\n            // echo out the deps + vulns found\n            console.log('Tested %s dependencies for known vulnerabilities, %s',\n              res.dependencyCount,\n              chalk.bold.red('found ' +\n                uniqueCount +\n                ' vulnerabilit' + ies +\n                ', ' + vulns.length +\n                ' vulnerable ' +\n                paths + '.'));\n          } else {\n            console.log(chalk.green(' Tested %s dependencies for known ' +\n              'vulnerabilities, no vulnerable paths found.'),\n              res.dependencyCount);\n          }\n\n          return tryRequire(packageFile).then(function (pkg) {\n            options.packageLeading = pkg.prefix;\n            options.packageTrailing = pkg.suffix;\n            return interactive(res, pkg, policy).then(function (answers) {\n              return processAnswers(answers, policy, options);\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\nfunction interactive(test, pkg, policy) {\n  var vulns = test.vulnerabilities;\n  if (!policy) {\n    policy = {};\n  }\n\n  if (!pkg) { // only really happening in tests\n    pkg = {};\n  }\n\n  return new Promise(function (resolve) {\n    debug('starting questions');\n    var prompts = allPrompts.getUpdatePrompts(vulns, policy);\n    resolve(inquire(prompts, {}));\n  }).then(function (answers) {\n    var prompts = allPrompts.getPatchPrompts(vulns, policy);\n    return inquire(prompts, answers);\n  }).then(function (answers) {\n    var prompts = allPrompts.getIgnorePrompts(vulns, policy);\n    return inquire(prompts, answers);\n  }).then(function (answers) {\n    var prompts = allPrompts.nextSteps(pkg, test.ok ? false : answers);\n    return inquire(prompts, answers);\n  }).then(function (answers) {\n    if (pkg.shrinkwrap) {\n      answers['misc-build-shrinkwrap'] = true;\n    }\n    return answers;\n  });\n}\n\nfunction inquire(prompts, answers) {\n  if (prompts.length === 0) {\n    return Promise.resolve(answers);\n  }\n  return new Promise(function (resolve) {\n    inquirer.prompt(prompts).then(function (theseAnswers) {\n      _.extend(answers, theseAnswers);\n      resolve(answers);\n    });\n  });\n}\n\nfunction processAnswers(answers, policy, options) {\n  if (!options) {\n    options = {};\n  }\n  options.packageLeading = options.packageLeading || '';\n  options.packageTrailing = options.packageTrailing || '';\n  // allow us to capture the answers the users gave so we can combine this\n  // the scenario running\n  if (options.json) {\n    return Promise.resolve(JSON.stringify(answers, '', 2));\n  }\n\n  var cwd = process.cwd();\n  var packageFile = path.resolve(cwd, 'package.json');\n\n  var pkg = {};\n\n  analytics.add('answers', Object.keys(answers).map(function (key) {\n    // if we're looking at a reason, skip it\n    if (key.indexOf('-reason') !== -1) {\n      return;\n    }\n\n    // ignore misc questions, like \"add snyk test to package?\"\n    if (key.indexOf('misc-') === 0) {\n      return;\n    }\n\n    var answer = answers[key];\n    var res = {\n      vulnId: answer.vuln.id,\n      choice: answer.choice,\n      from: answer.vuln.from.slice(1),\n    };\n\n    if (answer.vuln.grouped) {\n      res.batchMain = !!answer.vuln.grouped.main;\n      res.batch = true;\n    }\n\n    return res;\n  }).filter(Boolean));\n\n  var tasks = answersToTasks(answers);\n  debug(tasks);\n\n  var live = !options['dry-run'];\n  var snykVersion = '*';\n\n  var res = protect.generatePolicy(policy, tasks, live, options.packageManager)\n  .then(function (policy) {\n    if (!live) {\n      // if this was a dry run, we'll throw an error to bail out of the\n      // promise chain, then in the catch, check the error.code and if\n      // it matches `DRYRUN` we'll return the text and not an error\n      // (which avoids the exit code 1).\n      var e = new Error('This was a dry run: nothing changed');\n      e.code = 'DRYRUN';\n      throw e;\n    }\n\n    return policy.save(cwd, spinner).then(function () {\n      // don't do this during testing\n      if (isCI || process.env.TAP) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        exec('git add .snyk', {\n          cwd: cwd,\n        }, function (error, stdout, stderr) {\n          if (error) {\n            debug('error adding .snyk to git', error);\n          }\n\n          if (stderr) {\n            debug('stderr adding .snyk to git', stderr.trim());\n          }\n\n          // resolve either way\n          resolve();\n        });\n      });\n    });\n  })\n  .then(function () {\n    // re-read the package.json - because the generatePolicy can apply\n    // an `npm install` which will change the deps\n    return fs.readFile(packageFile, 'utf8')\n      .then(JSON.parse)\n      .then(function (updatedPkg) {\n        pkg = updatedPkg;\n      });\n  })\n  .then(getVersion)\n  .then(function (v) {\n    debug('snyk version: %s', v);\n    // little hack to circumvent local testing where the version will\n    // be the git branch + commit\n    if (v.match(/^\\d+\\./) === null) {\n      v = '*';\n    } else {\n      v = '^' + v;\n    }\n    snykVersion = v;\n  })\n  .then(function () {\n    analytics.add('add-snyk-test', answers['misc-add-test']);\n    if (!answers['misc-add-test']) {\n      return;\n    }\n\n    debug('adding `snyk test` to package');\n\n    if (!pkg.scripts) {\n      pkg.scripts = {};\n    }\n\n    var test = pkg.scripts.test;\n    var cmd = 'snyk test';\n    if (test && test !== 'echo \"Error: no test specified\" && exit 1') {\n      // only add the test if it's not already in the test\n      if (test.indexOf(cmd) === -1) {\n        pkg.scripts.test = cmd + ' && ' + test;\n      }\n    } else {\n      pkg.scripts.test = cmd;\n    }\n  })\n  .then(function () {\n    analytics.add('add-snyk-protect', answers['misc-add-protect']);\n    if (!answers['misc-add-protect']) {\n      return;\n    }\n\n    debug('adding `snyk protect` to package');\n\n    if (!pkg.scripts) {\n      pkg.scripts = {};\n    }\n\n    pkg.scripts['snyk-protect'] = 'snyk protect';\n\n    var cmd = 'npm run snyk-protect';\n    var runScript = pkg.scripts.prepublish;\n    if (runScript) {\n      // only add the prepublish if it's not already in the prepublish\n      if (runScript.indexOf(cmd) === -1) {\n        pkg.scripts.prepublish = cmd + '; ' + runScript;\n      }\n    } else {\n      pkg.scripts.prepublish = cmd;\n    }\n\n    // legacy check for `postinstall`, if `npm run snyk-protect` is in there\n    // we'll replace it with `true` so it can be cleanly swapped out\n    var postinstall = pkg.scripts.postinstall;\n    if (postinstall && postinstall.indexOf(cmd) !== -1) {\n      pkg.scripts.postinstall = postinstall.replace(cmd, 'true');\n    }\n\n    pkg.snyk = true;\n  })\n  .then(function () {\n    var lbl = 'Updating package.json...';\n    if (answers['misc-add-test'] || answers['misc-add-protect']) {\n      debug('updating %s', packageFile);\n\n      if (undefsafe(pkg, 'dependencies.snyk') ||\n          undefsafe(pkg, 'peerDependencies.snyk') ||\n          undefsafe(pkg, 'optionalDependencies.snyk')) {\n        // nothing to do as the user already has Snyk\n        // TODO decide whether we should update the version being used\n        // and how do we reconcile if the global install is older\n        // than the local version?\n      } else {\n        if (answers['misc-add-protect']) {\n          if (!pkg.dependencies) {\n            pkg.dependencies = {};\n          }\n          pkg.dependencies.snyk = snykVersion;\n          lbl = 'Adding Snyk to production dependencies ' +\n                '(used by snyk protect)';\n\n          // but also check if we should remove it from devDependencies\n          if (undefsafe(pkg, 'devDependencies.snyk')) {\n            delete pkg.devDependencies.snyk;\n          }\n        } else if (!undefsafe(pkg, 'devDependencies.snyk')) {\n          if (!pkg.devDependencies) {\n            pkg.devDependencies = {};\n          }\n          lbl = 'Adding Snyk to devDependencies (used by npm test)';\n          pkg.devDependencies.snyk = snykVersion;\n        }\n      }\n    }\n\n    if (answers['misc-add-test'] || answers['misc-add-protect'] ||\n          tasks.update.length) {\n      var packageString = options.packageLeading + JSON.stringify(pkg, '', 2) +\n                          options.packageTrailing;\n      return spinner(lbl)\n        .then(fs.writeFile(packageFile, packageString))\n        .then(spinner.clear(lbl));\n    }\n  })\n  .then(function () {\n    if (answers['misc-build-shrinkwrap'] && tasks.update.length) {\n      debug('updating shrinkwrap');\n\n      var lbl = 'Updating npm-shrinkwrap.json...';\n      return spinner(lbl)\n        .then(npm.bind(null, 'shrinkwrap', null, live, cwd, null))\n        .then(spinner.clear(lbl));\n    }\n  })\n  .then(function () {\n    if (answers['misc-test-no-monitor']) { // allows us to automate tests\n      return {\n        id: 'test',\n      };\n    }\n\n    debug('running monitor');\n    var lbl = 'Remembering current dependencies for future ' +\n      'notifications...';\n    return snyk.modules(cwd)\n      .then(spinner(lbl))\n      .then(snyk.monitor.bind(null, cwd, {\n        method: 'wizard',\n      }))\n      .then(spinner.clear(lbl));\n  })\n  .then(function (monitorRes) {\n    var endpoint = url.parse(config.API);\n    var leader = '';\n    if (monitorRes.org) {\n      leader = '/org/' + monitorRes.org;\n    }\n    endpoint.pathname = leader + '/monitor/' + monitorRes.id;\n    var monitorUrl = url.format(endpoint);\n    endpoint.pathname = leader + '/manage';\n    var manageUrl = url.format(endpoint);\n\n    return (options.newPolicy ?\n      // if it's a newly created file\n      '\\nYour policy file has been created with the actions you\\'ve ' +\n        'selected, add it to your source control (`git add .snyk`).' :\n      // otherwise we updated it\n      '\\nYour .snyk policy file has been successfully updated.') +\n      '\\nTo review your policy, run `snyk policy`.\\n\\n' +\n      'You can see a snapshot of your dependencies here:\\n' +\n      monitorUrl + '\\n\\n' +\n      (monitorRes.isMonitored ?\n      'We\\'ll notify you when relevant new vulnerabilities are ' +\n      'disclosed.\\n\\n' :\n      chalk.bold.red('Project is inactive, so notifications are turned off.\\n' +\n      'Activate this project here: ' + manageUrl + '\\n')) +\n      (monitorRes.trialStarted ?\n      chalk.yellow('You\\'re over the free plan usage limit, \\n' +\n      'and are now on a free 14-day premium trial.\\n' +\n      'View plans here: ' + manageUrl + '\\n\\n') :\n      '');\n  })\n  .catch(function (error) {\n    // if it's a dry run - exit with 0 status\n    if (error.code === 'DRYRUN') {\n      return error.message;\n    }\n\n    throw error;\n  });\n\n  return res;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/version.js":"module.exports = require('../../lib/version');","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/protect/prompts.js":"module.exports = {\n  getUpdatePrompts: getUpdatePrompts,\n  getPatchPrompts: getPatchPrompts,\n  getIgnorePrompts: getIgnorePrompts,\n  getPrompts: getPrompts,\n  nextSteps: nextSteps,\n  startOver: startOver,\n};\n\nvar _ = require('../../../dist/lodash-min');\nvar semver = require('semver');\nvar fmt = require('util').format;\nvar debug = require('debug')('snyk');\nvar protect = require('../../../lib/protect');\nvar moduleToObject = require('snyk-module');\nvar undefsafe = require('undefsafe');\nvar config = require('../../../lib/config');\nvar snykPolicy = require('snyk-policy');\n\n// via http://stackoverflow.com/a/4760279/22617\nfunction sort(prop) {\n  var sortOrder = 1;\n  if (prop[0] === '-') {\n    sortOrder = -1;\n    prop = prop.substr(1);\n  }\n\n  return function (a, b) {\n    var result = (a[prop] < b[prop]) ? -1 : (a[prop] > b[prop]) ? 1 : 0;\n    return result * sortOrder;\n  };\n}\n\nfunction sortUpgradePrompts(a, b) {\n  var res = 0;\n\n  // first sort by module affected\n  if (!a.from[1]) {\n    return -1;\n  }\n\n  if (!b.from[1]) {\n    return 1;\n  }\n\n  var pa = moduleToObject(a.from[1]);\n  var pb = moduleToObject(b.from[1]);\n  res = sort('name')(pa, pb);\n  if (res !== 0) {\n    return res;\n  }\n\n  // we should have the same module, so the depth should be the same\n  if (a.upgradePath[1] && b.upgradePath[1]) {\n    // put upgrades ahead of patches\n    if (b.upgradePath[1] === false) {\n      return 1;\n    }\n    var pua = moduleToObject(a.upgradePath[1]);\n    var pub = moduleToObject(b.upgradePath[1]);\n\n    res = semver.compare(pua.version, pub.version) * -1;\n\n    if (res !== 0) {\n      return res;\n    }\n  } else {\n    if (a.upgradePath[1]) {\n      return -1;\n    }\n\n    if (b.upgradePath[1]) {\n      return 1;\n    }\n\n    // if no upgrade, then hopefully a patch\n    res = sort('publicationTime')(b, a);\n  }\n\n  return res;\n}\n\nfunction sortPatchPrompts(a, b) {\n  var res = 0;\n\n  // first sort by module affected\n  var afrom = a.from.slice(1).pop();\n  var bfrom = b.from.slice(1).pop();\n\n  if (!afrom) {\n    return -1;\n  }\n\n  if (!bfrom[1]) {\n    return 1;\n  }\n\n  var pa = moduleToObject(afrom);\n  var pb = moduleToObject(bfrom);\n  res = sort('name')(pa, pb);\n  if (res !== 0) {\n    return res;\n  }\n\n  // if no upgrade, then hopefully a patch\n  res = sort('publicationTime')(b, a);\n\n  return res;\n}\n\nfunction stripInvalidPatches(vulns) {\n  // strip the irrelevant patches from the vulns at the same time, collect\n  // the unique package vulns\n  return vulns.map(function (vuln) {\n    // strip verbose meta\n    delete vuln.description;\n    delete vuln.credit;\n\n    if (vuln.patches) {\n      vuln.patches = vuln.patches.filter(function (patch) {\n        return semver.satisfies(vuln.version, patch.version);\n      });\n\n      // sort by patchModification, then pick the latest one\n      vuln.patches = vuln.patches.sort(function (a, b) {\n        return b.modificationTime < a.modificationTime ? -1 : 1;\n      }).slice(0, 1);\n\n      // FIXME hack to give all the patches IDs if they don't already\n      if (vuln.patches[0] && !vuln.patches[0].id) {\n        vuln.patches[0].id = vuln.patches[0].urls[0].split('/').slice(-1).pop();\n      }\n    }\n\n    return vuln;\n  });\n\n}\n\nfunction getPrompts(vulns, policy) {\n  return getUpdatePrompts(vulns, policy)\n                  .concat(getPatchPrompts(vulns, policy))\n                  .concat(getIgnorePrompts(vulns, policy));\n}\n\nfunction getPatchPrompts(vulns, policy) {\n  debug('getPatchPrompts');\n  if (!vulns || vulns.length === 0) {\n    return [];\n  }\n\n  var res = stripInvalidPatches(_.cloneDeep(vulns)).filter(function (vuln) {\n    // if there's any upgrade available, then remove it\n    return canBeUpgraded(vuln) ? false : true;\n  });\n\n  // sort by vulnerable package and the largest version\n  res.sort(sortPatchPrompts);\n\n  // console.log(res.map(_ => `${_.name}@${_.version}`));\n\n  var copy = {};\n  var offset = 0;\n  // mutate our objects so we can try to group them\n  // note that I use slice first becuase the `res` array will change length\n  // and `reduce` _really_ doesn't like when you change the array under\n  // it's feet\n  res.slice(0).reduce(function (acc, curr, i, all) {\n    // var upgrades = curr.upgradePath[1];\n    // otherwise it's a patch and that's hidden for now\n    if (curr.patches && curr.patches.length) {\n      // TODO allow for cross over patches on modules (i.e. patch can work\n      // on A-1 and A-2)\n      var last = curr.id;\n\n      if (acc[curr.id]) {\n        last = curr.id;\n      } else {\n        // try to find the right vuln id based on the publication times\n        last = (all.filter(function (vuln) {\n          var patch = vuln.patches[0];\n\n          // don't select the one we're looking at\n\n          if (curr.id === vuln.id) {\n            return false;\n          }\n\n          // only look at packages with the same name\n          if (curr.name !== vuln.name || !patch) {\n            return false;\n          }\n\n          // and ensure the patch can be applied to *our* module version\n          if (semver.satisfies(curr.version, patch.version)) {\n\n            // finally make sure the publicationTime is newer than the curr\n            // vulnerability\n            if (curr.publicationTime < vuln.publicationTime) {\n              debug('found alternative location for %s@%s (%s by %s) in %s',\n                curr.name, curr.version, patch.version, curr.id, vuln.id);\n              return true;\n            }\n          }\n        }).shift() || curr).id;\n\n      }\n\n      if (!acc[last]) {\n        // only copy the biggest change\n        copy[last] = _.cloneDeep(curr);\n        acc[last] = curr;\n        return acc;\n      }\n\n      // only happens on the 2nd time around\n      if (!acc[last].grouped) {\n        acc[last].grouped = {\n          affected: moduleToObject(acc[last].name + '@' + acc[last].version),\n          main: true,\n          id: acc[last].id + '-' + i,\n          count: 1,\n          upgrades: [{\n            // all this information is used when the user selects group patch\n            // specifically: in ./tasks.js~42\n            from: acc[last].from,\n            filename: acc[last].__filename,\n            patches: acc[last].patches,\n            version: acc[last].version,\n          },],\n          patch: true,\n        };\n\n        acc[last].grouped.affected.full = acc[last].name;\n\n        // splice this vuln into the list again so if the user choses to review\n        // they'll get this individual vuln and remediation\n        copy[last].grouped = {\n          main: false,\n          requires: acc[last].grouped.id,\n        };\n\n        res.splice(i + offset, 0, copy[last]);\n        offset++;\n      }\n\n      acc[last].grouped.count++;\n\n      curr.grouped = {\n        main: false,\n        requires: acc[last].grouped.id,\n      };\n\n      // add the from path to our group upgrades if we don't have it already\n      var have = !!acc[last].grouped.upgrades.filter(function (upgrade) {\n        return upgrade.from.join(' ') === curr.from.join(' ');\n      }).length;\n\n      if (!have) {\n        acc[last].grouped.upgrades.push({\n          from: curr.from,\n          filename: curr.__filename,\n          patches: curr.patches,\n          version: curr.version,\n        });\n      } else {\n        if (!acc[last].grouped.includes) {\n          acc[last].grouped.includes = [];\n        }\n        acc[last].grouped.includes.push(curr.id);\n      }\n    }\n\n    return acc;\n  }, {});\n\n  // FIXME this should not just strip those that have an upgrade path, but\n  // take into account the previous answers, and if the package has been\n  // upgraded, it should be left *out* of our list.\n  res = res.filter(function (curr) {\n    // if (curr.upgradePath[1]) {\n    //   return false;\n    // }\n\n    if (!curr.patches || curr.patches.length === 0) {\n      return false;\n    }\n\n    return true;\n  });\n\n  // console.log(res.map(_ => _.grouped));\n  var prompts = generatePrompt(res, policy, 'p');\n\n\n  return prompts;\n\n}\n\nfunction getIgnorePrompts(vulns, policy) {\n  debug('getIgnorePrompts');\n  if (!vulns || vulns.length === 0) {\n    return [];\n  }\n\n  var res = stripInvalidPatches(_.cloneDeep(vulns)).filter(function (vuln) {\n    // remove all patches and updates\n\n    // if there's any upgrade available\n    if (canBeUpgraded(vuln)) {\n      return false;\n    }\n\n    if (vuln.patches && vuln.patches.length) {\n      return false;\n    }\n\n    return true;\n  });\n\n  var prompts = generatePrompt(res, policy, 'i');\n\n  return prompts;\n\n}\n\nfunction getUpdatePrompts(vulns, policy) {\n  debug('getUpdatePrompts');\n  if (!vulns || vulns.length === 0) {\n    return [];\n  }\n\n  var res = stripInvalidPatches(_.cloneDeep(vulns)).filter(function (vuln) {\n    // only keep upgradeable\n    return canBeUpgraded(vuln);\n  });\n\n  // sort by vulnerable package and the largest version\n  res.sort(sortUpgradePrompts);\n\n  var copy = null;\n  var offset = 0;\n  // mutate our objects so we can try to group them\n  // note that I use slice first becuase the `res` array will change length\n  // and `reduce` _really_ doesn't like when you change the array under\n  // it's feet\n  res.slice(0).reduce(function (acc, curr, i) {\n    var from = curr.from[1];\n\n    if (!acc[from]) {\n      // only copy the biggest change\n      copy = _.cloneDeep(curr);\n      acc[from] = curr;\n      return acc;\n    }\n\n    var upgrades = curr.upgradePath.slice(-1).shift();\n    // otherwise it's a patch and that's hidden for now\n    if (upgrades && curr.upgradePath[1]) {\n      if (!acc[from].grouped) {\n        acc[from].grouped = {\n          affected: moduleToObject(from),\n          main: true,\n          id: acc[from].id + '-' + i,\n          count: 1,\n          upgrades: [],\n        };\n        acc[from].grouped.affected.full = from;\n\n        // splice this vuln into the list again so if the user choses to review\n        // they'll get this individual vuln and remediation\n        copy.grouped = {\n          main: false,\n          requires: acc[from].grouped.id,\n        };\n\n        res.splice(i + offset, 0, copy);\n        offset++;\n      }\n\n      acc[from].grouped.count++;\n\n      curr.grouped = {\n        main: false,\n        requires: acc[from].grouped.id,\n      };\n\n      var p = moduleToObject(upgrades);\n      if (p.name !== acc[from].grouped.affected.name &&\n        (' ' + acc[from].grouped.upgrades.join(' ') + ' ')\n          .indexOf(p.name + '@') === -1) {\n        debug('+ adding %s to upgrades', upgrades);\n        acc[from].grouped.upgrades.push(upgrades);\n      }\n    }\n\n    return acc;\n  }, {});\n\n  // now strip anything that doesn't have an upgrade path\n  res = res.filter(function (curr) {\n    return !!curr.upgradePath[1];\n  });\n\n  var prompts = generatePrompt(res, policy, 'u');\n\n  return prompts;\n}\n\nfunction canBeUpgraded(vuln) {\n  if (vuln.bundled) {\n    return false;\n  }\n\n  if (vuln.shrinkwrap) {\n    return false;\n  }\n\n  return vuln.upgradePath.some(function (pkg, i) {\n    // if the upgade path is to upgrade the module to the same range the\n    // user already asked for, then it means we need to just blow that\n    // module away and re-install\n    if (vuln.from.length > i && pkg === vuln.from[i]) {\n      return true;\n    }\n\n    // if the upgradePath contains the first two elements, that is\n    // the project itself (i.e. jsbin) then the direct dependency can be\n    // upgraded. Note that if the first two elements\n    if (vuln.upgradePath.slice(0, 2).filter(Boolean).length) {\n      return true;\n    }\n  });\n}\n\nfunction generatePrompt(vulns, policy, prefix) {\n  if (!prefix) {\n    prefix = '';\n  }\n  if (!vulns) {\n    vulns = []; // being defensive, but maybe we should throw an error?\n  }\n\n  var skipAction = {\n    value: 'skip', // the value that we get in our callback\n    key: 's',\n    name: 'Skip', // the text the user sees\n  };\n\n  var ignoreAction = {\n    value: 'ignore',\n    key: 'i',\n    meta: { // arbitrary data that we'll merged into the `value` later on\n      days: 30,\n    },\n    short: 'Ignore',\n    name: 'Set to ignore for 30 days (updates policy)',\n  };\n\n  var patchAction = {\n    value: 'patch',\n    key: 'p',\n    short: 'Patch',\n    name: 'Patch (modifies files locally, updates policy for `snyk protect` ' +\n      'runs)',\n  };\n\n  var updateAction = {\n    value: 'update',\n    key: 'u',\n    short: 'Upgrade',\n    name: null, // updated below to the name of the package to update\n  };\n\n  var prompts = vulns.map(function (vuln, i) {\n    var id = vuln.id || ('node-' + vuln.name + '@' + vuln.below);\n\n    id += '-' + prefix + i;\n\n    // make complete copies of the actions, otherwise we'll mutate the object\n    var ignore = _.cloneDeep(ignoreAction);\n    var skip = _.cloneDeep(skipAction);\n    var patch = _.cloneDeep(patchAction);\n    var update = _.cloneDeep(updateAction);\n    var review = {\n      value: 'review',\n      short: 'Review',\n      name: 'Review issues separately',\n    };\n\n    var choices = [];\n\n    var from = vuln.from.slice(1).filter(Boolean).shift();\n\n    // FIXME this should be handled a litle more gracefully\n    if (vuln.from.length === 1) {\n      console.log('');\n      var error = new Error(vuln.upgradePath[0]);\n      error.code = 'updatepackage';\n      throw error;\n    }\n    var vulnIn = vuln.from.slice(-1).pop();\n    var severity = vuln.severity[0].toUpperCase() + vuln.severity.slice(1);\n\n    var infoLink = '- info: ' + config.ROOT;\n    var messageIntro;\n    var fromText = false;\n    var group = vuln.grouped && vuln.grouped.main ? vuln.grouped : false;\n\n    if (group) {\n      infoLink += '/package/npm/' + group.affected.name + '/' +\n        group.affected.version;\n      var joiningText = group.patch ? 'in' : 'via';\n      var issues = vuln.type === 'license' ? 'issues' : 'vulnerabilities';\n      messageIntro = fmt(\n        '%s %s introduced %s %s',\n        group.count, issues, joiningText, group.affected.full);\n    } else {\n      infoLink += '/vuln/' + vuln.id;\n      messageIntro = fmt(\n        '%s severity %s found in %s, introduced via',\n        severity, vuln.type === 'license' ? 'issue' : 'vuln', vulnIn, from);\n      messageIntro += '\\n- desc: ' + vuln.title;\n      fromText = (from !== vuln.from.slice(1).join(' > ') ?\n          '- from: ' + vuln.from.slice(1).join(' > ') : '');\n    }\n\n    var note = false;\n    if (vuln.note) {\n      if (group && group.patch) {\n\n      } else {\n        note = '- note: ' + vuln.note;\n      }\n    }\n\n    var res = {\n      when: function (answers) {\n        var res = true;\n        // only show this question if the user choose to review the details\n        // of the vuln\n        if (vuln.grouped && !vuln.grouped.main) {\n          // find how they answered on the top level question\n          var groupAnswer = Object.keys(answers).map(function (key) {\n            if (answers[key].meta) {\n              // this meta.groupId only appears on a \"review\" choice, and thus\n              // this map will pick out those vulns that are specifically\n              // associated with this review group.\n              if (answers[key].meta.groupId === vuln.grouped.requires) {\n                if (answers[key].choice === 'ignore' &&\n                    answers[key].meta.review) {\n                  answers[key].meta.vulnsInGroup.push({\n                    id: vuln.id,\n                    from: vuln.from,\n                  });\n                  return false;\n                }\n\n                return answers[key];\n              }\n            }\n            return false;\n          }).filter(Boolean);\n\n          if (!groupAnswer.length) {\n            debug('no group answer: show %s when %s', vuln.id, false);\n            return false;\n          }\n\n          // if we've upgraded, then stop asking\n          var updatedTo = null;\n          res = groupAnswer.filter(function (answer) {\n            if (answer.choice === 'update') {\n              updatedTo = answer;\n              return true;\n            }\n          }).length === 0;\n\n          if (!res) {\n            // echo out what would be upgraded\n            var via = 'Fixed through previous upgrade instruction to ' +\n              updatedTo.vuln.upgradePath[1];\n            console.log(['', messageIntro, infoLink, via].join('\\n'));\n          }\n        }\n\n        if (res) {\n          console.log(''); // blank line between prompts...kinda lame, sorry\n        }\n\n        debug('final show %s when %s', vuln.id, res);\n\n        return res; // true = show next\n      },\n      name: id,\n      type: 'list',\n      message: [messageIntro, infoLink, fromText, note, '  Remediation options']\n        .filter(Boolean).join('\\n'),\n    };\n\n    var upgradeAvailable = canBeUpgraded(vuln);\n\n    // note: the language presented the user is \"upgrade\" rather than \"update\"\n    // this change came long after all this code was written. I've decided\n    // *not* to update all the variables referring to `update`, but just\n    // to warn my dear code-reader that this is intentional.\n    if (upgradeAvailable) {\n      choices.push(update);\n      var toPackage = vuln.upgradePath.filter(Boolean).shift();\n\n      var word = toPackage === from ? 'Re-install ' : 'Upgrade to ';\n\n      update.short = word + toPackage;\n      var out = word + toPackage;\n      var toPackageVersion = moduleToObject(toPackage).version;\n      var diff = semver.diff(moduleToObject(from).version, toPackageVersion);\n      var lead = '';\n      var breaking = 'potentially breaking change';\n      if (diff === 'major') {\n        lead = ' (' + breaking + ', ';\n      } else {\n        lead = ' (';\n      }\n\n      lead += 'triggers upgrade to ';\n      if (group && group.upgrades.length) {\n        out += lead + group.upgrades.join(', ') + ')';\n      } else {\n        var last = vuln.upgradePath.slice(-1).shift();\n        if (toPackage !== last) {\n          out += lead + last + ')';\n        } else if (diff === 'major') {\n          out += ' (' + breaking + ')';\n        }\n      }\n      update.name = out;\n    } else {\n      // No upgrade available (as per no patch)\n      var reason = '';\n\n      if (vuln.shrinkwrap) {\n        reason = fmt('upgrade unavailable as %s@%s is shrinkwrapped by %s',\n          vuln.name, vuln.version, vuln.shrinkwrap);\n      } else if (vuln.bundled) {\n        reason = fmt('upgrade unavailable as %s is bundled in vulnerable %s',\n          vuln.bundled.slice(-1).pop(), vuln.name);\n      } else {\n        reason = 'no sufficient upgrade available we\\'ll notify you when ' +\n          'there is one';\n      }\n\n      choices.push({\n        value: 'skip',\n        key: 'u',\n        short: 'Upgrade (none available)',\n        name: 'Upgrade (' + reason + ')',\n      });\n    }\n\n    var patches = null;\n\n    if (upgradeAvailable && group) {\n\n    } else {\n      if (vuln.patches && vuln.patches.length) {\n        // check that the version we have has a patch available\n        patches = protect.patchesForPackage(vuln);\n\n        if (patches !== null) {\n          if (!upgradeAvailable) {\n            patch.default = true;\n          }\n          res.patches = patches;\n\n          if (group) {\n            patch.name = fmt('Patch the %s vulnerabilities', group.count);\n          }\n\n          choices.push(patch);\n        }\n      }\n    }\n\n    // only show patch option if this is NOT a grouped upgrade\n    if (upgradeAvailable === false || !group) {\n      if (patches === null) {\n        // add a disabled option saying that patch isn't available\n        // note that adding `disabled: true` does nothing, so the user can\n        // actually select this option. I'm not 100% it's the right thing,\n        // but we'll keep a keen eye on user feedback.\n        choices.push({\n          value: 'skip',\n          key: 'p',\n          short: 'Patch (none available)',\n          name: 'Patch (no patch available, we\\'ll notify you when ' +\n            'there is one)',\n        });\n      }\n    }\n\n    if (group) {\n      review.meta = {\n        groupId: group.id,\n        review: true,\n      };\n      choices.push(review);\n\n      ignore.meta.review = true;\n      ignore.meta.groupId = group.id;\n      ignore.meta.vulnsInGroup = [];\n    }\n\n\n    if (patches === null && !upgradeAvailable) {\n      ignore.default = true;\n    }\n\n    choices.push(ignore);\n    choices.push(skip);\n\n    // look for a default - the `res.default` needs to be the index\n    // of the choice, so we remap the choices to include the index, value of\n    // choice and whether it was supposed to be a default. If the user is\n    // updating their policy options, then we select the choice they had\n    // before, otherwise we select the default\n    res.default = (choices.map(function (choice, i) {\n      return { i: i, default: choice.default };\n    }).filter(function (choice) {\n      return choice.default;\n    }).shift() || { i: 0 }).i;\n\n    // kludge to make sure that we get the vuln in the user selection\n    res.choices = choices.map(function (choice) {\n      var value = choice.value;\n      // this allows us to pass more data into the inquirer results\n      if (vuln.grouped && !vuln.grouped.main) {\n        if (!choice.meta) {\n          choice.meta = {};\n        }\n        choice.meta.groupId = vuln.grouped.requires;\n      }\n      choice.value = {\n        meta: choice.meta,\n        vuln: vuln,\n        choice: value, // this is the string \"update\", \"ignore\", etc\n      };\n      return choice;\n    });\n\n    res.vuln = vuln;\n\n    return res;\n  });\n\n  // zip together every prompt and a prompt asking \"why\", note that the `when`\n  // callback controls whether not to prompt the user with this question,\n  // in this case, we always show if the user choses to ignore.\n  prompts = prompts.reduce(function (acc, curr) {\n    acc.push(curr);\n    // console.log(curr.choices[0].value.vuln);\n    var rule = snykPolicy.getByVuln(policy, curr.choices[0].value.vuln);\n    var defaultAnswer = 'None given';\n    if (rule && rule.type === 'ignore') {\n      defaultAnswer = rule.reason;\n    }\n    var issue = curr.choices[0].value.vuln &&\n          curr.choices[0].value.vuln.type === 'license' ?\n          'issue' : 'vulnerability';\n    acc.push({\n      name: curr.name + '-reason',\n      message: '[audit] Reason for ignoring ' + issue + '?',\n      default: defaultAnswer,\n      when: function (answers) {\n        if (!answers[curr.name]) {\n          return false;\n        }\n        return answers[curr.name].choice === 'ignore';\n      },\n    });\n    return acc;\n  }, []);\n\n  return prompts;\n}\n\nfunction startOver() {\n  return {\n    name: 'misc-start-over',\n    message: 'Do you want to revisit your existing policy [y] or only update ' +\n      'it [N]?',\n    type: 'confirm',\n    default: false,\n  };\n}\n\nfunction nextSteps(pkg, prevAnswers) {\n  var skipProtect = false;\n  var prompts = [];\n  var i;\n\n  i = (undefsafe(pkg, 'scripts.test') || '').indexOf('snyk test');\n  if (i === -1) {\n    prompts.push({\n      name: 'misc-add-test',\n      message: 'Add `snyk test` to package.json file to fail test on newly ' +\n        'disclosed vulnerabilities?\\n' +\n        'This will require authentication via `snyk auth` when running tests.',\n      type: 'confirm',\n      default: false,\n    });\n  }\n\n  // early exit if prevAnswers is false (when snyk test.ok === true)\n  if (prevAnswers === false) {\n    return prompts;\n  }\n\n  i = (undefsafe(pkg, 'scripts.prepublish') || '').indexOf('snyk-pro');\n\n  // if `snyk protect` doesn't already appear, then check if we need to add it\n  if (i === -1) {\n    skipProtect = Object.keys(prevAnswers).every(function (key) {\n      return prevAnswers[key].choice !== 'patch';\n    });\n  } else {\n    skipProtect = true;\n  }\n\n  if (!skipProtect) {\n    prompts.push({\n      name: 'misc-add-protect',\n      message: 'Add `snyk protect` as a package.json installation hook to ' +\n        'apply chosen patches on install?',\n      type: 'confirm',\n      default: true,\n    });\n  }\n\n  return prompts;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/index.js":"var protect = module.exports = {\n  ignore: require('./ignore'),\n  update: require('./update'),\n  patch: require('./patch'),\n  patchesForPackage: require('./patches-for-package'),\n  generatePolicy: generatePolicy,\n};\n\nvar debug = require('debug')('snyk');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar _ = require('../../dist/lodash-min');\n\nfunction generatePolicy(policy, tasks, live, packageManager) {\n  var promises = ['ignore', 'update', 'patch'].filter(function (task) {\n    return tasks[task].length;\n  }).map(function (task) {\n    return protect[task](tasks[task], live, packageManager);\n  });\n\n  return Promise.all(promises).then(function (res) {\n    // we're squashing the arrays of arrays into a flat structure\n    // with only non-false values\n    var results = _.flattenDeep(res).filter(Boolean);\n\n    // then we merge the configs together using the original config\n    // as the baseline (this lets us retain the user's existing config)\n    results.unshift(policy);\n    var newPolicy = _.merge.apply(_, results);\n\n    debug(JSON.stringify(newPolicy, '', 2));\n\n    return newPolicy;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/ignore.js":"module.exports = ignore;\n\nvar debug = require('debug')('snyk');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar stripVersions = require('./strip-versions');\nvar oneDay = 1000 * 60 * 60 * 24;\n\nfunction ignore(data) {\n  return new Promise(function (resolve) {\n    var config = {};\n    config.ignore = data.map(function (res) {\n      var vuln = res.vuln;\n      var days = res.meta.days || 30;\n      var ignoreRule = {};\n      ignoreRule[stripVersions(vuln.from.slice(1)).join(' > ')] = {\n        reason: res.meta.reason,\n        expires: new Date(Date.now() + (oneDay * days)).toJSON(),\n      };\n      ignoreRule.vulnId = vuln.id;\n      return ignoreRule;\n    }).reduce(function (acc, curr) {\n      if (!acc[curr.vulnId]) {\n        acc[curr.vulnId] = [];\n      }\n\n      var id = curr.vulnId;\n      delete curr.vulnId;\n      acc[id].push(curr);\n\n      return acc;\n    }, {});\n\n    // final format looks like test/fixtures/protect-interactive-config.json\n    debug('ignore config', config);\n\n    resolve(config);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/strip-versions.js":"module.exports = stripVersions;\n\nvar moduleToObject = require('snyk-module');\n\nfunction stripVersions(packages) {\n  return packages.map(function (pkg) {\n    return moduleToObject(pkg).name;\n  });\n}","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/update.js":"module.exports = update;\n\nvar debug = require('debug')('snyk');\nvar chalk = require('chalk');\nvar _ = require('../../dist/lodash-min');\nvar moduleToObject = require('snyk-module');\nvar semver = require('semver');\nvar errors = require('../error');\nvar npm = require('../npm');\nvar yarn = require('../yarn');\nvar spinner = require('../spinner');\n\nfunction update(packages, live, pkgManager) {\n  pkgManager = pkgManager || 'npm';\n  var lbl = 'Applying updates using ' + pkgManager + '...';\n  var error = false;\n\n  return spinner(lbl).then(function () {\n    // the uninstall doesn't need versions in the strings\n    // but install *does* so we build up arrays of both\n    var upgradeWithoutVersions = [];\n\n    var upgrade = packages\n    .map(function (vuln) {\n      var remediation = vuln.upgradePath.filter(Boolean)[0];\n      upgradeWithoutVersions.push(remediation.split('@').shift());\n\n      return {\n        remediation: remediation,\n        type: vuln.parentDepType || 'prod',\n      };\n    })\n    .reduce(function (ups, vuln) {\n      if (!ups[vuln.type]) {\n        ups[vuln.type] = [];\n      }\n      ups[vuln.type].push(vuln.remediation);\n      return ups;\n    }, {});\n\n    debug('to upgrade', upgrade);\n\n    if (upgrade.length === 0) {\n      return;\n    }\n\n    var toUninstall = _.unique(upgradeWithoutVersions);\n    var promise = uninstall(pkgManager, toUninstall, live)\n    .then(function () {\n      var prodUpdate = (upgrade.prod ?\n        install(pkgManager, findUpgrades(upgrade.prod), live) :\n        Promise.resolve(true))\n        .catch(function (e) {\n          error = e;\n          return false;\n        });\n      var devUpdate = (upgrade.dev ?\n        installDev(pkgManager, findUpgrades(upgrade.dev), live) :\n        Promise.resolve(true))\n        .catch(function (e) {\n          error = e;\n          return false;\n        });\n      return Promise.all([prodUpdate, devUpdate])\n      .then(function (results) {\n        return results[0] && results[1];\n      });\n    });\n    return promise;\n  })\n  .then(spinner.clear(lbl))\n  .then(function (res) {\n    if (error) {\n      console.error(chalk.red(errors.message(error)));\n    }\n    return res;\n  });\n}\n\nfunction install(pkgManager, upgrades, live) {\n  return pkgManager === 'yarn' ?\n    yarn('add', upgrades, live) :\n    npm('install', upgrades, live);\n}\n\nfunction installDev(pkgManager, upgrades, live) {\n  return pkgManager === 'yarn' ?\n    yarn('add', upgrades, live, null, ['--dev']) :\n    npm('install', upgrades, live, null, ['--save-dev']);\n}\n\nfunction uninstall(pkgManager, toUninstall, live) {\n  return pkgManager === 'yarn' ?\n    yarn('remove', toUninstall, live) :\n    npm('uninstall', toUninstall, live);\n}\n\nfunction findUpgrades(packages) {\n  return packages\n  .map(moduleToObject)\n  .reduce(function (acc, curr) {\n    var have = acc.filter(function (pkg) {\n      return pkg.name === curr.name;\n    }).pop();\n\n    if (have) {\n      if (semver.gt(curr.version, have.version)) {\n        have.version = curr.version;\n      }\n    } else {\n      acc.push(curr);\n    }\n\n    return acc;\n  }, [])\n  .map(function (pkg) {\n    return pkg.name + '@' + pkg.version;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/patch.js":"module.exports = patch;\n\nvar now = new Date();\n\nvar debug = require('debug')('snyk');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar chalk = require('chalk');\nvar recursive = require('snyk-recursive-readdir');\nvar tempfile = require('tempfile');\nvar fs = require('then-fs');\nvar path = require('path');\nvar _ = require('../../dist/lodash-min');\nvar applyPatch = require('./apply-patch');\nvar stripVersions = require('./strip-versions');\nvar getVulnSource = require('./get-vuln-source');\nvar dedupe = require('./dedupe-patches');\nvar writePatchFlag = require('./write-patch-flag');\nvar spinner = require('../spinner');\nvar errors = require('../error');\nvar analytics = require('../analytics');\nvar getPatchFile = require('./fetch-patch');\nvar ensurePatchExists = require('./ensure-patch');\n\n// note: cwd is optional and mostly used for testing\nfunction patch(vulns, live, cwd) {\n  var lbl = 'Applying patches...';\n\n  // we also need to normalise the patches. specifically, using the __filename\n  // as the identifier, we'll ensure the vuln.id is unique, so we don't have\n  // multiple attempts to patch the same location (which leads to failed patch\n  // due to \"Reversed (or previously applied)\").\n\n  var noPatchRequired = {};\n  if (vulns.length) {\n    vulns = vulns.reduce(function (acc, curr) {\n      var key = curr.id + ':' + curr.__filename;\n      if (!noPatchRequired[key]) {\n        noPatchRequired[key] = [];\n        acc.push(curr);\n      } else {\n        noPatchRequired[key].push(curr);\n      }\n      return acc;\n    }, []);\n  }\n\n  var errorList = [];\n  return ensurePatchExists().then(spinner(lbl)).then(function () {\n    // the target directory where our module name will live\n    vulns.forEach(function (vuln) {\n      vuln.source = getVulnSource(vuln, cwd, live);\n    });\n\n    var deduped = dedupe(vulns);\n    debug('patching %s', deduped.packages.length);\n\n    // find the patches, pull them down off the web, save them in a temp file\n    // then apply each individual patch - but do it one at a time (via reduce)\n    var promises = deduped.packages.reduce(function (acc, vuln) {\n      return acc.then(function (res) {\n        var patches = vuln.patches; // this is also deduped in `dedupe`\n\n        if (patches === null) {\n          debug('no patch available for ' + vuln.id);\n          analytics.add('no-patch', vuln.from.slice(1).join(' > '));\n          return res;\n        }\n\n        analytics.add('patch', vuln.from.slice(1).join(' > '));\n\n        // the colon doesn't like Windows, ref: https://git.io/vw2iO\n        var fileSafeId = vuln.id.replace(/:/g, '-');\n        var flag = path.resolve(vuln.source, '.snyk-' + fileSafeId + '.flag');\n        var oldFlag = path.resolve(vuln.source, '.snyk-' + vuln.id + '.flag');\n\n        // get the patches on the local fs\n        var promises = patches.urls.map(function (url) {\n          var filename = tempfile('.' + fileSafeId + '.snyk-patch');\n          return getPatchFile(url, filename, 1).then(function (patch) {\n            // check whether there's a trace of us having patched before\n            return fs.exists(flag).then(function (exists) {\n              // if the file doesn't exist, look for the old style filename\n              // in case and for backward compat\n              return exists || fs.exists(oldFlag);\n            }).then(function (exists) {\n              if (!exists) {\n                return patch;\n              }\n\n              // else revert the patch\n              return new Promise(function (resolve, reject) {\n                recursive(vuln.source, function (error, files) {\n                  if (error) {\n                    return reject(error);\n                  }\n\n                  resolve(Promise.all(files.filter(function (file) {\n                    return file.slice(-5) === '.orig';\n                  }).map(function (file) {\n                    return fs.rename(file, path.dirname(file) + '/' +\n                      path.basename(file).slice(0, -5));\n                  })));\n                });\n              }).then(function () {\n                return patch;\n              });\n            });\n          }).then(function (patch) {\n            if (patch === false) {\n              debug('already patched %s', vuln.id);\n              return vuln;\n            }\n\n            debug('applying patch file for %s: \\n%s\\n%s', vuln.id, url, patch);\n\n            return applyPatch(patch, vuln, live).then(function () {\n              return true;\n            }, function (e) {\n              errorList.push(e);\n              return false;\n            }).then(function (ok) {\n              return ok ? vuln : false;\n            });\n          });\n        });\n\n        return Promise.all(promises).then(function (result) {\n          res.push(result);\n          return res; // this is what makes the waterfall reduce chain work\n        });\n      });\n    }, Promise.resolve(deduped.removed));\n\n    var promise = promises.then(function (res) {\n      var patched = _.flatten(res).filter(Boolean);\n\n      if (!live) {\n        debug('[skipping - dry run]');\n        return patched;\n      }\n\n      return Promise.all(patched.map(writePatchFlag.bind(null, now)));\n    }).then(function (patched) {\n      patched = patched.reduce(function (acc, curr) {\n        var key = curr.id + ':' + curr.__filename;\n\n        if (noPatchRequired[key]) {\n          noPatchRequired[key].forEach(function (vuln) {\n            acc.push(vuln);\n          });\n        }\n\n        acc.push(curr);\n\n        return acc;\n      }, []);\n\n      var config = {};\n\n      // this reduce function will look to see if the patch actually resolves\n      // more than one vulnerability, and if it does, it'll replicate the\n      // patch rule against the *other* vuln.ids. This will happen when the user\n      // runs the wizard and selects to apply a patch that fixes more than one\n      // vuln.\n      var mapped = patched.map(patchRule).reduce(function (acc, curr, i) {\n        var vuln = patched[i];\n        if (vuln.grouped && vuln.grouped.includes) {\n          vuln.grouped.includes.forEach(function (id) {\n            var rule = _.cloneDeep(curr);\n            rule.vulnId = id;\n            acc.push(rule);\n          });\n        }\n\n        acc.push(curr);\n\n        return acc;\n      }, []);\n\n      config.patch = mapped.reduce(function (acc, curr) {\n        if (!acc[curr.vulnId]) {\n          acc[curr.vulnId] = [];\n        }\n\n        var id = curr.vulnId;\n        delete curr.vulnId;\n        acc[id].push(curr);\n\n        return acc;\n      }, {});\n\n      debug('patched', config);\n\n      return config;\n    });\n\n    return promise;\n  }).then(spinner.clear(lbl)).then(function (res) {\n    if (errorList.length) {\n      errorList.forEach(function (error) {\n        console.log(chalk.red(errors.message(error)));\n      });\n      throw new Error('Please email support@snyk.io if this problem persists.');\n    }\n\n    return res;\n  });\n}\n\nfunction patchRule(vuln) {\n  var rule = {\n    vulnId: vuln.id,\n  };\n  rule[stripVersions(vuln.from.slice(1)).join(' > ')] = {\n    patched: now.toJSON(),\n  };\n  return rule;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk-recursive-readdir/index.js":"var fs = require('fs')\nvar p = require('path')\nvar minimatch = require('minimatch')\n\nfunction patternMatcher(pattern) {\n  return function(path, stats) {\n    var minimatcher = new minimatch.Minimatch(pattern, {matchBase: true})\n    return (!minimatcher.negate || stats.isFile()) && minimatcher.match(path)\n  }\n}\n\nfunction toMatcherFunction(ignoreEntry) {\n  if (typeof ignoreEntry == 'function') {\n    return ignoreEntry\n  } else {\n    return patternMatcher(ignoreEntry)\n  }\n}\n\nfunction readdir(path, ignores, callback) {\n  if (typeof ignores == 'function') {\n    callback = ignores\n    ignores = []\n  }\n  ignores = ignores.map(toMatcherFunction)\n\n  var list = []\n\n  fs.readdir(path, function(err, files) {\n    if (err) {\n      return callback(err)\n    }\n\n    var pending = files.length\n    if (!pending) {\n      // we are done, woop woop\n      return callback(null, list)\n    }\n\n    files.forEach(function(file) {\n      var filePath = p.join(path, file)\n      fs.stat(filePath, function(_err, stats) {\n        if (_err) {\n          return callback(_err)\n        }\n\n        if (ignores.some(function(matcher) { return matcher(filePath, stats) })) {\n          pending -= 1\n          if (!pending) {\n            return callback(null, list)\n          }\n          return null\n        }\n\n        if (stats.isDirectory()) {\n          readdir(filePath, ignores, function(__err, res) {\n            if (__err) {\n              return callback(__err)\n            }\n\n            list = list.concat(res)\n            pending -= 1\n            if (!pending) {\n              return callback(null, list)\n            }\n          })\n        } else {\n          list.push(filePath)\n          pending -= 1\n          if (!pending) {\n            return callback(null, list)\n          }\n        }\n\n      })\n    })\n  })\n}\n\nmodule.exports = readdir\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/apply-patch.js":"module.exports = applyPatch;\n\nvar debug = require('debug')('snyk');\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar exec = require('child_process').exec;\nvar path = require('path');\nvar errorAnalytics = require('../analytics').single;\n\nfunction applyPatch(patch, vuln, live) {\n  var cwd = vuln.source;\n  return new Promise(function (resolve, reject) {\n\n    var cmd = 'patch -p1 --backup --verbose < ' + patch;\n    var test = ' --dry-run';\n\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n\n    var relative = path.relative(process.cwd(), cwd);\n    debug('%s$ %s', relative, cmd + test);\n\n    // do a dry run first, otherwise the patch can \"succeed\" (exit 0) if it\n    // only manages to patch *some* of the chunks (and leave the file partly\n    // patched).\n    exec(cmd + test, {\n      cwd: cwd,\n      env: process.env,\n    }, function (error, stdout) { // stderr is ignored\n      var out = stdout.trim();\n      if (error || out.indexOf('FAILED') !== -1) {\n        debug('patch command failed', relative, error, out);\n        return patchError(error, out, relative, vuln).catch(reject);\n      }\n\n      if (!live) {\n        return resolve();\n      }\n\n      // if it was okay, and it wasn't a dry-run, then let's do it for real\n      exec(cmd, {\n        cwd: cwd,\n        env: process.env,\n      }, function (error, stdout) {\n        var out = stdout.trim();\n        if (error || out.indexOf('FAILED') !== -1) {\n          debug('patch command failed', relative, error, out);\n          return patchError(error, out, relative, vuln).catch(reject);\n        }\n\n        debug('patch succeed', out);\n\n        resolve();\n      });\n    });\n  });\n}\n\nfunction patchError(error, stdout, dir, vuln) {\n  if (error && error.code === 'ENOENT') {\n    error.message = 'Failed to patch: the target could not be found.';\n    return Promise.reject(error);\n  }\n\n  return new Promise(function (resolve, reject) {\n    var id = vuln.id;\n\n    // sneaky trick to do two sys calls in one.\n    exec('npm -v && patch -v', {\n      env: process.env,\n    }, function (patchVError, versions) { // stderr is ignored\n      var parts = versions.split('\\n');\n      var npmVersion = parts.shift();\n      var patchVersion = parts.shift();\n\n      // post the raw error to help diagnose\n      errorAnalytics({\n        command: 'patch-fail',\n        metadata: {\n          from: vuln.from.slice(1),\n          vulnId: id,\n          packageName: vuln.name,\n          packageVersion: vuln.version,\n          package: vuln.name + '@' + vuln.version,\n          error: error,\n          stdout: stdout,\n          'patch-version': patchVersion,\n          'npm-version': npmVersion,\n        },\n      });\n\n      // this is a general \"patch failed\", since we already check if the\n      // patch was applied via a flag, this means something else went\n      // wrong, so we'll ask the user for help to diganose.\n      var filename = path.relative(process.cwd(), dir);\n      error = new Error('\"' + filename + '\" (' + id + ')');\n      error.code = 'FAIL_PATCH';\n\n      reject(error);\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/get-vuln-source.js":"module.exports = getVulnSource;\n\nvar debug = require('debug')('snyk');\nvar resolve = require('snyk-resolve');\nvar path = require('path');\nvar statSync = require('fs').statSync;\nvar moduleToObject = require('snyk-module');\n\nfunction getVulnSource(vuln, cwd, live) {\n  var from = vuln.from.slice(1).map(function (pkg) {\n    return moduleToObject(pkg).name;\n  });\n\n  var viaPath = path.resolve(\n    cwd || process.cwd(),\n    'node_modules',\n    from.join('/node_modules/')\n  );\n\n  var source = vuln.__filename ?\n      path.dirname(vuln.__filename) :\n      viaPath;\n\n  // try to stat the directory, if it throws, it doesn't exist...\n  try {\n    statSync(source);\n  } catch (e) {\n    // ...which means the package is located in a parent path (from an\n    // npm dedupe process), so we remove the module name from the path\n    // and use the `resolve` package to navigate the node_modules up\n    // through parent directories.\n    try {\n      source = resolve.sync(from.slice(-1).pop(), viaPath);\n    } catch (e) {\n      if (live) {\n        throw e;\n      }\n\n      // otherwise this is a dry run so we don't mind that it won't be\n      // able to patch - likely a scenario run, so it's fine that the\n      // patch target won't be found\n    }\n    debug('found better source for package: %s', source);\n  }\n\n  return source;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/dedupe-patches.js":"module.exports = dedupe;\n\nvar debug = require('debug')('snyk:patch');\nvar patchesForPackage = require('./patches-for-package');\n\nfunction dedupe(source) {\n  var removed = [];\n\n  var names = source.reduce(function (acc, vuln) {\n    if (Array.isArray(vuln.patches)) {\n      // strip down to the only paches that can be applied\n      vuln.patches = patchesForPackage(vuln);\n    }\n\n    var key = vuln.name + vuln.version + vuln.from.join('>');\n\n    var other = acc[key];\n    if (other) {\n      debug('dupe found on %s & %s', vuln.id, other.id);\n      if (vuln.publicationTime > other.publicationTime) {\n        debug('stripping %s', other.id);\n        removed.push(other);\n        acc[key] = vuln;\n      } else {\n        removed.push(vuln);\n      }\n    } else {\n      acc[key] = vuln;\n    }\n\n    return acc;\n  }, {});\n\n  // turn back into an array\n  var packages = Object.keys(names).map(function (key) {\n    return names[key];\n  });\n\n  return {\n    packages: packages,\n    removed: removed,\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/patches-for-package.js":"module.exports = patchesForPackage;\n\nvar semver = require('semver');\n\nfunction patchesForPackage(vuln) {\n  return vuln.patches.filter(function (patch) {\n    if (semver.satisfies(vuln.version, patch.version)) {\n      return (patch.urls || []).length ? patch : false;\n    }\n    return false;\n  })[0] || null;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/write-patch-flag.js":"module.exports = writePatchFlag;\n\nvar debug = require('debug')('snyk');\nvar fs = require('then-fs');\nvar path = require('path');\nvar Promise = require ('es6-promise').Promise; // jshint ignore:line\n\nfunction writePatchFlag(now, vuln) {\n  if (!vuln) {\n    vuln = now;\n    now = new Date();\n  }\n\n  debug('writing flag for %s', vuln.id);\n  var promise;\n  // the colon doesn't like Windows, ref: https://git.io/vw2iO\n  var fileSafeId = vuln.id.replace(/:/g, '-');\n  var flag = path.resolve(vuln.source, '.snyk-' + fileSafeId + '.flag');\n  if (vuln.grouped && vuln.grouped.includes) {\n    debug('found addition vulns to write flag files for');\n    var writePromises = [fs.writeFile(flag, now.toJSON(), 'utf8')];\n    debug(flag);\n    vuln.grouped.includes.forEach(function (id) {\n      var fileSafeId = vuln.id.replace(/:/g, '-');\n      var flag = path.resolve(vuln.source, '.snyk-' + fileSafeId + '.flag');\n      debug(flag);\n      writePromises.push(fs.writeFile(flag, now.toJSON(), 'utf8'));\n    });\n    promise = Promise.all(writePromises);\n  } else {\n    promise = fs.writeFile(flag, now.toJSON(), 'utf8');\n  }\n\n  return promise.then(function () {\n    return vuln;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/fetch-patch.js":"module.exports = getPatchFile;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar request = require('request');\nvar fs = require('then-fs');\nvar analytics = require('../analytics');\n\nfunction getPatchFile(url, filename, attempts) {\n  return new Promise(function (resolve, reject) {\n    request(url)\n      .on('response', function (response) {\n        if (response.statusCode >= 400) {\n          if (!attempts) {\n            var err = new Error('Failed to fetch patch file');\n            analytics.add('patch-fetch-fail', {\n              message: err.message,\n              code: response.statusCode,\n            });\n            return reject(err);\n          }\n          return resolve(getPatchFile(url, filename, attempts - 1));\n        }\n      })\n      .on('end', function () {\n        resolve(filename);\n      })\n      .on('error', function (err) {\n        if (!attempts) {\n          analytics.add('patch-fetch-fail', {\n            message: err.message,\n            code: err.code,\n          });\n          return reject(err);\n        }\n        resolve(getPatchFile(url, filename, attempts - 1));\n      })\n      .pipe(fs.createWriteStream(filename));\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/protect/ensure-patch.js":"module.exports = ensurePatchExists;\n\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\nvar hasbin = require('hasbin');\nvar analytics = require('../analytics');\n\nfunction ensurePatchExists() {\n  return new Promise(function (resolve, reject) {\n    return hasbin('patch', function (exists) {\n      if (!exists) {\n        var err = new Error('Snyk couldn\\'t patch the specified ' +\n                            'vulnerabilities because GNU\\'s patch is not ' +\n                            'available. Please install \\'patch\\' ' +\n                            'and try again.');\n        analytics.add('patch-binary-missing', {\n          message: err.message,\n        });\n        return reject(err);\n      }\n      return resolve();\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/protect/tasks.js":"module.exports = answersToTasks;\n\nvar debug = require('debug')('snyk');\nvar _ = require('../../../dist/lodash-min');\n\nfunction answersToTasks(answers) {\n  var tasks = {\n    ignore: [],\n    update: [],\n    patch: [],\n    skip: [],\n  };\n\n  Object.keys(answers).forEach(function (key) {\n    // if we're looking at a reason, skip it\n    if (key.indexOf('-reason') !== -1) {\n      return;\n    }\n\n    // ignore misc questions, like \"add snyk test to package?\"\n    if (key.indexOf('misc-') === 0) {\n      return;\n    }\n\n    var answer = answers[key];\n    var task = answer.choice;\n    if (task === 'review' || task === 'skip') {\n      // task = 'skip';\n      return;\n    }\n\n    var vuln = answer.vuln;\n\n    if (task === 'patch' && vuln.grouped && vuln.grouped.upgrades) {\n      // ignore the first as it's the same one as this particular answer\n      debug('additional answers required: %s',\n        vuln.grouped.count - 1,\n        vuln.grouped);\n\n      var additional = vuln.grouped.upgrades.slice(1);\n\n      additional.forEach(function (upgrade) {\n        var copy = _.cloneDeep(vuln);\n        copy.from = upgrade.from;\n        copy.__filename = upgrade.filename;\n        copy.patches = upgrade.patches;\n        copy.version = upgrade.version;\n        tasks[task].push(copy);\n      });\n    }\n\n    if (task === 'ignore') {\n      answer.meta.reason = answers[key + '-reason'];\n      if (answer.meta.vulnsInGroup) {\n        // also ignore any in the group\n        answer.meta.vulnsInGroup.forEach(function (vuln) {\n          tasks[task].push({\n            meta: answer.meta,\n            vuln: vuln,\n          });\n        });\n      } else {\n        tasks[task].push(answer);\n      }\n    } else {\n      tasks[task].push(vuln);\n    }\n  });\n\n  return tasks;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/unpublished/prune.js":"module.exports = prune;\n\nfunction prune(pkg, shouldPrune) {\n  var remove = shouldPrune(pkg);\n  if (!remove) {\n    pkg.dependencies = {};\n  }\n\n  var deps = Object.keys(pkg.dependencies || {});\n\n  if (deps.length) {\n    remove = deps.filter(function (name) {\n      if (prune(pkg.dependencies[name], shouldPrune)) {\n        delete pkg.dependencies[name];\n        return false;\n      }\n      return true;\n    }).length;\n    remove = remove === 0;\n  }\n\n  return remove;\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/cli/commands/unpublished/walk.js":"module.exports = walk;\nvar Promise = require('es6-promise').Promise; // jshint ignore:line\n\nfunction walk(deps, filter) {\n  return new Promise(function (resolve) {\n    if (!deps) {\n\n      return resolve([]);\n    }\n\n    if (deps.dependencies) {\n      deps = deps.dependencies;\n    }\n\n    var promises = Object.keys(deps).map(function (name) {\n      return new Promise(function (resolve) {\n        return resolve(filter(deps[name], name, deps));\n      }).then(function (res) {\n        if (!res && deps[name] && deps[name].dep) {\n          return walk(deps[name].dependencies, filter);\n        }\n      });\n    });\n\n    resolve(Promise.all(promises));\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snyk/node_modules/snyk/lib/module-info/maven/mvn-tree-parse.js":"module.exports = parseTree;\n\nvar packageFormatVersion = 'mvn:0.0.1';\nvar newline = /[\\r\\n]+/g;\nvar logLabel = /^\\[\\w+\\]\\s*/gm;\nvar digraph = /digraph([\\s\\S]*?)\\}/g;\n\n// Parse the output from 'mvn dependency:tree -DoutputType=dot'\n// Requires Maven >= 2.2\nfunction parseTree(text) {\n  text = text.replace(logLabel, '');\n  return getRootProject(text);\n}\n\nfunction getRootProject(text) {\n  var projects = text.match(digraph);\n  var root = getProject(projects[0]);\n  // Add any subsequent projects to the root as dependencies\n  for (var i = 1; i < projects.length; i++) {\n    var project = getProject(projects[i], root);\n    root.dependencies[project.name] = project;\n  }\n  root.packageFormatVersion = packageFormatVersion;\n  return root;\n}\n\nfunction getProject(projectDump, parent) {\n  var lines = projectDump.split(newline);\n  var identity = dequote(lines[0]);\n  var deps = {};\n  for (var i = 1; i < lines.length - 1; i++) {\n    var line = lines[i];\n    var nodes = line.trim().split('->');\n    var source = dequote(nodes[0]);\n    var target = dequote(nodes[1]);\n    deps[source] = deps[source] || [];\n    deps[source].push(target);\n  }\n  return assemblePackage(identity, deps, parent);\n}\n\nfunction assemblePackage(source, projectDeps, parent) {\n  var sourcePackage = createPackage(source, parent);\n  var sourceDeps = projectDeps[source];\n  if (sourceDeps) {\n    for (var i = 0; i < sourceDeps.length; i++) {\n      var pkg = assemblePackage(sourceDeps[i], projectDeps, sourcePackage);\n      sourcePackage.dependencies[pkg.name] = pkg;\n    }\n  }\n  return sourcePackage;\n}\n\nfunction createPackage(pkgStr, parent) {\n  var range = getConstraint(pkgStr);\n  if (range) {\n    pkgStr = pkgStr.substring(0, pkgStr.indexOf(' '));\n  }\n  var parts = pkgStr.split(':');\n  var result = {\n    groupId: parts[0],\n    artifactId: parts[1],\n    packaging: parts[2],\n    version: parts[3],\n    name: parts[0] + ':' + parts[1],\n    dependencies: {},\n  };\n  var selfPkg = parts[0] + ':' + parts[1] + '@' + parts[3];\n  result.from = parent ?\n    parent.from.concat(selfPkg) :\n    [selfPkg];\n  if (parts.length === 5) {\n    result.scope = parts[4];\n  }\n  if (range) {\n    result.dep = range;\n  }\n  return result;\n}\n\nfunction dequote(str) {\n  return str.slice(str.indexOf('\"') + 1, str.lastIndexOf('\"'));\n}\n\nfunction getConstraint(str) {\n  var index = str.indexOf('selected from constraint');\n  if (index === -1) {\n    return null;\n  }\n  return str.slice(index + 25, str.lastIndexOf(')'));\n}\n"}